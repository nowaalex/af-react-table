{"version":3,"sources":["webpack://af-virtual-scroll/./src/models/RowsAggregator/utils/multiGroupBy/index.js","webpack://af-virtual-scroll/./src/models/RowsAggregator/utils/getSorter/index.js","webpack://af-virtual-scroll/./src/models/RowsAggregator/utils/sortGroups/index.js","webpack://af-virtual-scroll/./src/models/RowsAggregator/utils/flattenGroups/index.js","webpack://af-virtual-scroll/./src/models/RowsAggregator/index.js","webpack://af-virtual-scroll/./src/components/ComplexTable/style.module.scss?b8c6","webpack://af-virtual-scroll/./src/components/ComplexTable/index.js","webpack://af-virtual-scroll/./src/examples/complexTable(unstable)/basic/index.js"],"names":["indexesArray","groupDataKeysList","getRowData","lastGroupIndex","length","lastGroupDataKey","groupsMap","Map","rowIndex","row","tmpInnerObject","cellValue","innerObject","i","get","set","push","sortDataKey","sortDirection","a","b","row1","row2","v1","v2","sortGroups","depth","currentDepth","groupValues","values","group","sortCallback","getSorter","sort","flattenGroups","collapsedGroups","prefix","rowIndexes","idx","groupValue","subGroup","concatenated","concat","has","Array","isArray","apply","setFiltering","dataKey","value","this","filtersMap","toLowerCase","delete","setSorting","addGrouping","groupKeys","includes","clear","toggleCollapsedGroup","add","removeGrouping","indexOf","splice","from","rowsQuantity","v","multiGroupBy","filteredIndexes","grouped","groupedSorted","orderedIndexes","size","filter","flattenedGroups","hasGrouping","groupsSortedIndexes","noGroupsSortedIndexes","constructor","Set","makeAutoObservable","computed","equals","finalIndexes","merge","propertiesObj","Object","assign","HeaderLabel","observer","m","label","collectedProps","dragRef","useDrag","item","type","ref","className","css","onClick","aria-sort","undefined","HeaderInput","onChange","e","target","getCount","total","nested","getSum","j","SummaryCell","GroupsPanel","dropRef","useDrop","accept","drop","map","groupKey","onDoubleClick","GroupCell","columns","isCollapsed","groupPath","groupLabel","find","c","Fragment","style","marginLeft","col","totals","path","reduce","res","key","props","useState","RowsAggregator","useEffect","DndProvider","backend","HTML5Backend","cx","Table","renderRow","renderCell","CellsList","Cell","realRowIndex","colSpan","renderHeaderCells","renderFooter","normalizedVisibleColumns","some","rows","firstName","faker","lastName","country","getPureRandomLineHeight","estimatedRowHeight","render","cellData","rowData","color","textAlign","lineHeight","background"],"mappings":"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","file":"aab4abd9f04738ddcac7.js","sourcesContent":["const multiGroupBy = ( indexesArray, groupDataKeysList, getRowData ) => {\n\n    const lastGroupIndex = groupDataKeysList.length - 1;\n\n    if( process.env.NODE_ENV !== \"production\" ){\n        if( lastGroupIndex < 0 ){\n            throw new Error( \"lastGroupIndex < 0\" );\n        }\n    }\n\n    const lastGroupDataKey = groupDataKeysList[ lastGroupIndex ];\n    const groupsMap = new Map();\n   \n\n    for( let rowIndex of indexesArray ){\n        /*\n            It is better to start from indexes iteration, not from groups, to minimize getRowData calls\n        */\n        const row = getRowData( rowIndex );\n\n        let innerObject = groupsMap,\n            tmpInnerObject,\n            cellValue;\n\n        /*\n            We could put everything in one loop, but last iteration is different.\n        */\n        for( let i = 0; i < lastGroupIndex; i++ ){\n            cellValue = row[ groupDataKeysList[ i ] ];\n            tmpInnerObject = innerObject.get( cellValue );\n            if( !tmpInnerObject ){\n                tmpInnerObject = new Map();\n                innerObject.set( cellValue, tmpInnerObject );\n            }\n            innerObject = tmpInnerObject;\n        }\n\n        cellValue = row[ lastGroupDataKey ];\n        tmpInnerObject = innerObject.get( cellValue );\n\n        if( tmpInnerObject ){\n            tmpInnerObject.push( rowIndex );\n        }\n        else {\n            innerObject.set( cellValue, [ rowIndex ]);\n        }\n    }\n\n    return groupsMap;\n}\n\nexport default multiGroupBy;","const getSorter = ( getRowData, sortDataKey, sortDirection ) => ( a, b ) => {\n    const row1 = getRowData( a );\n    const row2 = getRowData( b );\n\n    if( row1 && row2 ){\n        const v1 = row1[ sortDataKey ];\n        const v2 = row2[ sortDataKey ];\n        return v1 > v2 ? sortDirection : v1 < v2 ? -sortDirection : 0;\n    }\n\n    return row1 ? sortDirection : row2 ? -sortDirection : 0;\n}\n\nexport default getSorter;","import getSorter from \"../getSorter\";\n\nconst sortGroups = ( groupsMap, getRowData, sortDataKey, sortDirection, depth, currentDepth = 0 ) => {\n\n    const groupValues = groupsMap.values();\n\n    if( currentDepth < depth - 1 ){\n        for( let group of groupValues ){\n            sortGroups( group, getRowData, sortDataKey, sortDirection, depth, currentDepth + 1 );\n        }\n    }\n    else{\n        const sortCallback = getSorter( getRowData, sortDataKey, sortDirection );\n\n        for( let group of groupValues ){\n            group.sort( sortCallback );\n        }\n    }\n}\n\nexport default sortGroups;","const flattenGroups = ( groupsMap, collapsedGroups, prefix = [], groupValues = [], rowIndexes = [] ) => {\n    let idx;\n    for( let [ groupValue, subGroup ] of groupsMap ){\n        const concatenated = prefix.concat( groupValue );\n        idx = -groupValues.push( concatenated );\n        rowIndexes.push( idx );\n        if( !collapsedGroups.has( idx ) ){\n            if( Array.isArray( subGroup ) ){\n                rowIndexes.push.apply( rowIndexes, subGroup );\n            }\n            else{\n                flattenGroups( subGroup, collapsedGroups, concatenated, groupValues, rowIndexes );\n            }\n        }\n    }\n\n    return { groupValues, rowIndexes };\n}\n\nexport default flattenGroups;","import { makeAutoObservable, computed } from \"mobx\"; \nimport multiGroupBy from \"./utils/multiGroupBy\";\nimport sortGroups from \"./utils/sortGroups\";\nimport flattenGroups from \"./utils/flattenGroups\";\nimport getSorter from \"./utils/getSorter\";\n\nclass RowsAggregator {\n\n    /* Provided from renderer */\n    rowsQuantity = 0;\n    getRowData = null;\n\n    /* Calculated inside model */\n    filtersMap = new Map();\n    groupKeys = [];\n    sortDataKey = \"\";\n    sortDirection = -1;\n\n    collapsedGroups = new Set();\n\n    setFiltering( dataKey, value ){\n        if( value ){\n            this.filtersMap.set( dataKey, value.toLowerCase() );\n        }\n        else{\n            this.filtersMap.delete( dataKey );\n        }\n    }\n\n    setSorting( dataKey ){\n        if( this.sortDataKey === dataKey ){\n            this.sortDirection *= -1;\n        }\n        this.sortDataKey = dataKey;\n    }\n\n    addGrouping( dataKey ){\n        if( !this.groupKeys.includes( dataKey ) ){\n            this.groupKeys.push( dataKey );\n            this.collapsedGroups.clear();\n        }\n    }\n\n    toggleCollapsedGroup( idx ){\n        if( this.collapsedGroups.has( idx ) ){\n            this.collapsedGroups.delete( idx );\n        }\n        else{\n            this.collapsedGroups.add( idx );\n        }\n    }\n\n    removeGrouping( dataKey ){\n        const idx = this.groupKeys.indexOf( dataKey );\n        if( idx !== -1 ){\n            this.groupKeys.splice( idx, 1 );\n            this.collapsedGroups.clear();\n        }\n    }\n\n    get orderedIndexes(){\n        return Array.from({ length: this.rowsQuantity }, ( v, i ) => i );\n    }\n\n    get grouped(){\n        return multiGroupBy( this.filteredIndexes, this.groupKeys, this.getRowData );\n    }\n\n    get groupedSorted(){\n        if( this.sortDataKey ){\n            sortGroups( this.grouped, this.getRowData, this.sortDataKey, this.sortDirection, this.groupKeys.length );\n        }\n        return this.grouped;\n    }\n\n    get flattenedGroups(){\n        return flattenGroups( this.groupedSorted, this.collapsedGroups );\n    }\n\n    get filteredIndexes(){\n        //return this.orderedIndexes;\n        const { filtersMap, orderedIndexes } = this;\n        if( this.filtersMap.size ){\n            const filteredIndexesArray = orderedIndexes.filter( idx => {\n                const row = this.getRowData( idx );\n                for( let [ dataKey, value ] of filtersMap ){\n                    if( !( \"\" + row[ dataKey ] ).toLowerCase().includes( value ) ){\n                        return false;\n                    }\n                }\n                return true;\n            });\n\n            return filteredIndexesArray;\n        }\n        return orderedIndexes;\n    }\n\n    \n    get noGroupsSortedIndexes(){\n        return this.sortDataKey ? this.filteredIndexes.sort( getSorter( this.getRowData, this.sortDataKey, this.sortDirection ) ) : this.filteredIndexes;\n    }\n\n    get groupsSortedIndexes(){\n        return this.flattenedGroups.rowIndexes;\n    }\n\n    get hasGrouping(){\n        return !!this.groupKeys.length;\n    }\n\n    get finalIndexes(){\n        return this.hasGrouping ? this.groupsSortedIndexes : this.noGroupsSortedIndexes;\n    }\n\n    constructor(){\n        makeAutoObservable( this, {\n            groupedSorted: computed({ equals: () => false }),\n            groupsSortedIndexes: computed({ equals: () => false }),\n            noGroupsSortedIndexes: computed({ equals: () => false }),\n            finalIndexes: computed({ equals: () => false }),\n            filteredIndexes: computed({ equals: () => false }),\n            orderedIndexes: computed({ equals: () => false })\n        });\n    }\n\n    merge( propertiesObj ){\n        Object.assign( this, propertiesObj );\n    }\n}\n\nexport default RowsAggregator;","// extracted by mini-css-extract-plugin\nexport default {\"wrapper\":\"_2B3KY_2EhDdLzl3od9PxI3\",\"sortableHeader\":\"_3xhCMieeqyydLLrsB_Rjwr\",\"input\":\"_7PdTV3zpJzO5l3JPCJbaz\",\"groupsPanel\":\"_24CQvBWd2KIxalcwIBcG6S\",\"groupLabel\":\"_1Pfh0g4BE_cuNHu46ByRkY\",\"columnSummaries\":\"QsUrLMXUKybinaPXO0z0B\"};","import { Fragment, useState, useEffect } from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport RowsAggregator from \"models/RowsAggregator\";\nimport Table from \"../Table\";\nimport cx from \"utils/cx\";\nimport css from \"./style.module.scss\";\nimport { HTML5Backend } from \"react-dnd-html5-backend\";\nimport { useDrag, useDrop, DndProvider } from \"react-dnd\";\n\nconst HEADER_DND_TYPE = \"h\";\n\nconst HeaderLabel = observer(({ m, dataKey, label }) => {\n\n    const [ collectedProps, dragRef ] = useDrag({ item: {\n        type: HEADER_DND_TYPE,\n        dataKey\n    }});\n\n    return (\n        <div\n            ref={dragRef}\n            className={css.sortableHeader}\n            onClick={() => m.setSorting( dataKey )}\n            aria-sort={m.sortDataKey === dataKey?(m.sortDirection===1?\"ascending\":\"descending\"):undefined}\n        >\n            {label}\n        </div>\n    );\n});\n\nconst HeaderInput = observer(({ m, dataKey }) => (\n    <input\n        className={css.input}\n        value={m.filtersMap.get( dataKey )||\"\"}\n        onChange={e => m.setFiltering( dataKey, e.target.value )}\n    />\n));\n\nconst getCount = rowIndexes => {\n\n    let total = 0;\n\n    if( Array.isArray( rowIndexes ) ){\n        total += rowIndexes.length;\n    }\n    else {\n        for( let nested of rowIndexes.values() ){\n            total += getCount( nested );\n        }\n    }\n\n    return total;\n}\n\nconst getSum = ( rowIndexes, dataKey, getRowData ) => {\n\n    let total = 0;\n\n    if( Array.isArray( rowIndexes ) ){\n        let row;\n        for( let j of rowIndexes ){\n            row = getRowData( j );\n            total += row[ dataKey ];\n        }\n    }\n    else {\n        for( let nested of rowIndexes.values() ){\n            total += getSum( nested, dataKey, getRowData );\n        }\n    }\n\n    return total;\n}\n\nconst SummaryCell = observer(({ m, type, dataKey, rowIndexes }) => {\n\n    if( type === \"count\" ){\n        return getCount( rowIndexes );\n    }\n\n    if( type === \"sum\" ){\n        return getSum( rowIndexes, dataKey, m.getRowData )\n    }\n\n    return null;\n});\n\nconst GroupsPanel = observer(({ m }) => {\n\n    const [ collectedProps, dropRef ] = useDrop({\n        accept: HEADER_DND_TYPE,\n        drop( item ){\n            m.addGrouping( item.dataKey );\n        }\n    });\n\n    return (\n        <div className={css.groupsPanel} ref={dropRef}>\n            {m.groupKeys.length ? m.groupKeys.map( groupKey => (\n                <div className={css.groupLabel} key={groupKey} onDoubleClick={() => m.removeGrouping( groupKey )}>\n                    {groupKey}\n                </div>\n            )) : \"Drag column headers here to group by column\" }\n        </div>\n    );\n});\n\nconst getInMap = ( map, path ) => path.reduce(( res, key ) => res.get( key ), map );\n\nconst GroupCell = observer(({ m, columns, idx }) => {\n\n    const isCollapsed = m.collapsedGroups.has( idx );\n\n    if( m.hasGrouping ){\n\n        const groupPath = m.flattenedGroups.groupValues[~idx];\n\n        if( groupPath ){\n\n            const lastGroupIndex = groupPath.length - 1;\n            const groupKey = m.groupKeys[lastGroupIndex];\n            const groupLabel = columns.find( c => c.dataKey === groupKey ).label;\n\n            return (\n                <Fragment>\n                    <span\n                        onClick={() => m.toggleCollapsedGroup( idx )}\n                        style={{\n                            marginLeft: `${(lastGroupIndex)*2}em`\n                        }}\n                    >\n                        {isCollapsed ? \"+\" : \"-\"}\n                    </span>\n                    &nbsp;\n                    {groupLabel}:&nbsp;{groupPath[lastGroupIndex]}\n                    {columns.length ? (\n                        <span className={css.columnSummaries}>\n                            {columns.map( col => col.totals ? (\n                                <span key={col.dataKey}>\n                                    {col.label}:\n                                    &nbsp;\n                                    <SummaryCell\n                                        m={m}\n                                        type={col.totals}\n                                        dataKey={col.dataKey}\n                                        rowIndexes={getInMap(m.grouped,groupPath)}\n                                    />\n                                </span>\n                            ) : null)}\n                        </span>\n                    ) : null}\n                </Fragment>\n            );\n        }\n        \n    }\n\n    return null;\n});\n\nconst ComplexTable = ({ rowsQuantity, getRowData, className, ...props }) => {\n\n    const [ m ] = useState(() => new RowsAggregator());\n\n    const { finalIndexes } = m;\n\n    const renderRow = ( rowIndex, columns, getRowData, renderCell, CellsList, Cell ) => {\n        const realRowIndex = finalIndexes[ rowIndex ];\n        return (\n            <tr key={realRowIndex}>\n                {realRowIndex < 0 ? (\n                    <td colSpan={columns.length}>\n                        <GroupCell m={m} idx={realRowIndex} columns={columns} />\n                    </td>\n                ) : (\n                    <CellsList\n                        rowIndex={realRowIndex}\n                        columns={columns}\n                        getRowData={getRowData}\n                        renderCell={renderCell}\n                        Cell={Cell}\n                    />\n                )}\n            </tr>\n        );\n    }\n\n    const renderHeaderCells = columns => columns.map(({ dataKey, label }) => (\n        <th key={dataKey}>\n            <HeaderLabel m={m} dataKey={dataKey} label={label} />\n            <HeaderInput m={m} dataKey={dataKey} />\n        </th>\n    ));  \n\n    useEffect(() => m.merge({ rowsQuantity, getRowData }));\n\n    const renderFooter = normalizedVisibleColumns => normalizedVisibleColumns.some( col => !!col.totals ) ? (\n        <tfoot>\n            <tr>\n                {normalizedVisibleColumns.map(({ dataKey, totals }) => (\n                    <td key={dataKey}>\n                        <SummaryCell m={m} dataKey={dataKey} type={totals} rowIndexes={m.filteredIndexes} />\n                    </td>\n                ))}\n            </tr>\n        </tfoot>\n    ) : null;\n\n    return (\n        <DndProvider backend={HTML5Backend}>\n            <div className={cx(css.wrapper,className)}>\n                <GroupsPanel m={m} />\n                <Table\n                    rowsQuantity={finalIndexes.length}\n                    getRowData={getRowData}\n                    renderRow={renderRow}\n                    renderHeaderCells={renderHeaderCells}\n                    renderFooter={renderFooter}\n                    {...props}\n                />\n            </div>\n        </DndProvider> \n    );\n}\n\nexport default observer( ComplexTable );","import { ComplexTable as Table } from  \"af-virtual-scroll\";\nimport faker from \"faker\";\n\nconst rows = Array.from({ length: 10000 }, (v, i) => ({\n    i,\n    firstName: faker.name.firstName(),\n    lastName: faker.name.lastName(),\n    country: faker.address.country()\n}));\n\n/* Math.random is not the best option, because same rowIndex should produce same height */\nconst getPureRandomLineHeight = rowIndex => 20 + ( rowIndex % 53 ) + ( rowIndex % 87 );\n\nconst ComplexTable = () => (\n    <Table\n        rowsQuantity={rows.length}\n        getRowData={i => rows[ i ]}\n        estimatedRowHeight={30}\n        columns={[\n            {\n                dataKey: \"i\",\n                totals: \"sum\",\n                render: ( cellData, rowData, rowIndex ) => (\n                    <div style={{\n                        color: \"#000\",\n                        textAlign: \"center\",\n                        lineHeight: `${getPureRandomLineHeight(rowIndex)}px`,\n                        background: `hsl(${rowIndex*11%360},60%,60%)`\n                    }}>\n                        {cellData}\n                    </div>\n                )\n            },\n            {\n                dataKey: \"firstName\",\n                totals: \"count\"\n            },\n            \"lastName\",\n            \"country\"\n        ]}\n    />\n);\n\nexport default ComplexTable;"],"sourceRoot":""}