{"version":3,"sources":["webpack://af-virtual-scroll/./src/models/RowsAggregator/utils/multiGroupBy/index.js","webpack://af-virtual-scroll/./src/models/RowsAggregator/utils/getSorter/index.js","webpack://af-virtual-scroll/./src/models/RowsAggregator/utils/sortGroups/index.js","webpack://af-virtual-scroll/./src/models/RowsAggregator/utils/flattenGroups/index.js","webpack://af-virtual-scroll/./src/models/RowsAggregator/index.js","webpack://af-virtual-scroll/./src/components/ComplexTable/style.module.scss?b8c6","webpack://af-virtual-scroll/./src/components/ComplexTable/index.js","webpack://af-virtual-scroll/./src/examples/complexTable(beta)/basic/index.js"],"names":["indexesArray","groupDataKeysList","getRowData","lastGroupIndex","length","lastGroupDataKey","groupsMap","Map","rowIndex","row","tmpInnerObject","cellValue","innerObject","i","get","set","push","sortDataKey","sortDirection","a","b","row1","row2","v1","v2","sortGroups","depth","currentDepth","groupValues","values","group","sortCallback","getSorter","sort","flattenGroups","prefix","rowIndexes","groupValue","subGroup","Array","isArray","apply","setFiltering","dataKey","value","this","filtersMap","toLowerCase","delete","setSorting","addGrouping","groupKeys","includes","removeGrouping","splice","indexOf","from","rowsQuantity","v","multiGroupBy","filteredIndexes","grouped","groupedSorted","orderedIndexes","size","filter","idx","String","flattenedGroups","hasGrouping","groupsSortedIndexes","noGroupsSortedIndexes","constructor","shallowGroupsStore","makeAutoObservable","computed","equals","finalIndexes","merge","propertiesObj","Object","assign","HeaderLabel","observer","m","label","className","css","onClick","e","ctrlKey","aria-sort","undefined","HeaderInput","onChange","target","props","useState","RowsAggregator","useEffect","Table","renderRow","columns","renderCell","CellsList","Cell","realRowIndex","colSpan","renderTheadContents","map","cx","rows","firstName","faker","lastName","country","getPureRandomLineHeight","estimatedRowHeight","render","cellData","rowData","style","color","textAlign","lineHeight","background"],"mappings":"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","file":"d3c2ba4a11c6990a3ce4.js","sourcesContent":["const multiGroupBy = ( indexesArray, groupDataKeysList, getRowData ) => {\n\n    const lastGroupIndex = groupDataKeysList.length - 1;\n\n    if( process.env.NODE_ENV !== \"production\" ){\n        if( lastGroupIndex < 0 ){\n            throw new Error( \"lastGroupIndex < 0\" );\n        }\n    }\n\n    const lastGroupDataKey = groupDataKeysList[ lastGroupIndex ];\n    const groupsMap = new Map();\n   \n\n    for( let rowIndex of indexesArray ){\n        /*\n            It is better to start from indexes iteration, not from groups, to minimize getRowData calls\n        */\n        const row = getRowData( rowIndex );\n\n        let innerObject = groupsMap,\n            tmpInnerObject,\n            cellValue;\n\n        /*\n            We could put everything in one loop, but last iteration is different.\n        */\n        for( let i = 0; i < lastGroupIndex; i++ ){\n            cellValue = row[ groupDataKeysList[ i ] ];\n            tmpInnerObject = innerObject.get( cellValue );\n            if( !tmpInnerObject ){\n                tmpInnerObject = new Map();\n                innerObject.set( cellValue, tmpInnerObject );\n            }\n            innerObject = tmpInnerObject;\n        }\n\n        cellValue = row[ lastGroupDataKey ];\n        tmpInnerObject = innerObject.get( cellValue );\n\n        if( tmpInnerObject ){\n            tmpInnerObject.push( rowIndex );\n        }\n        else {\n            innerObject.set( cellValue, [ rowIndex ]);\n        }\n    }\n\n    return groupsMap;\n}\n\nexport default multiGroupBy;","const getSorter = ( getRowData, sortDataKey, sortDirection ) => ( a, b ) => {\n    const row1 = getRowData( a );\n    const row2 = getRowData( b );\n\n    if( row1 && row2 ){\n        const v1 = row1[ sortDataKey ];\n        const v2 = row2[ sortDataKey ];\n        return v1 > v2 ? sortDirection : v1 < v2 ? -sortDirection : 0;\n    }\n\n    return row1 ? sortDirection : row2 ? -sortDirection : 0;\n}\n\nexport default getSorter;","import getSorter from \"../getSorter\";\n\nconst sortGroups = ( groupsMap, getRowData, sortDataKey, sortDirection, depth, currentDepth = 0 ) => {\n\n    const groupValues = groupsMap.values();\n\n    if( currentDepth < depth - 1 ){\n        for( let group of groupValues ){\n            sortGroups( group, getRowData, sortDataKey, sortDirection, depth, currentDepth + 1 );\n        }\n    }\n    else{\n        const sortCallback = getSorter( getRowData, sortDataKey, sortDirection );\n\n        for( let group of groupValues ){\n            group.sort( sortCallback );\n        }\n    }\n}\n\nexport default sortGroups;","const flattenGroups = ( groupsMap, prefix = \"\", groupValues = [], rowIndexes = [] ) => {\n    for( let [ groupValue, subGroup ] of groupsMap ){\n        rowIndexes.push( -groupValues.push( prefix + groupValue ) );\n        if( Array.isArray( subGroup ) ){\n            rowIndexes.push.apply( rowIndexes, subGroup );\n        }\n        else{\n            flattenGroups( subGroup, prefix + groupValue + \".\", groupValues, rowIndexes );\n        }\n    }\n\n    return { groupValues, rowIndexes };\n}\n\nexport default flattenGroups;","import { makeAutoObservable, computed } from \"mobx\"; \nimport multiGroupBy from \"./utils/multiGroupBy\";\nimport sortGroups from \"./utils/sortGroups\";\nimport flattenGroups from \"./utils/flattenGroups\";\nimport getSorter from \"./utils/getSorter\";\n\nclass RowsAggregator {\n\n    /* Provided from renderer */\n    rowsQuantity = 0;\n    getRowData = null;\n\n    /* Calculated inside model */\n    filtersMap = new Map();\n    groupKeys = [];\n    sortDataKey = \"\";\n    sortDirection = -1;\n\n    shallowGroupsStore = new Map();\n\n    setFiltering( dataKey, value ){\n        if( value ){\n            this.filtersMap.set( dataKey, value.toLowerCase() );\n        }\n        else{\n            this.filtersMap.delete( dataKey );\n        }\n    }\n\n    setSorting( dataKey ){\n        if( this.sortDataKey === dataKey ){\n            this.sortDirection *= -1;\n        }\n        this.sortDataKey = dataKey;\n    }\n\n    addGrouping( dataKey ){\n        if( !this.groupKeys.includes( dataKey ) ){\n            this.groupKeys.push( dataKey );\n        }\n    }\n\n    removeGrouping( dataKey ){\n        this.groupKeys.splice( this.groupKeys.indexOf( dataKey ) >>> 0, 1 );\n    }\n\n    get orderedIndexes(){\n        return Array.from({ length: this.rowsQuantity }, ( v, i ) => i );\n    }\n\n    get grouped(){\n        return multiGroupBy( this.filteredIndexes, this.groupKeys, this.getRowData );\n    }\n\n    get groupedSorted(){\n        sortGroups( this.grouped, this.getRowData, this.sortDataKey, this.sortDirection, this.groupKeys.length );\n        return this.grouped;\n    }\n\n    get flattenedGroups(){\n        return flattenGroups( this.groupedSorted );\n    }\n\n    get filteredIndexes(){\n        const { filtersMap, orderedIndexes } = this;\n        if( this.filtersMap.size ){\n            const filteredIndexesArray = orderedIndexes.filter( idx => {\n                const row = this.getRowData( idx );\n                for( let [ dataKey, value ] of filtersMap ){\n                    if( !String( row[ dataKey ] ).toLowerCase().includes( value ) ){\n                        return false;\n                    }\n                }\n                return true;\n            });\n\n            return filteredIndexesArray;\n        }\n        return this.orderedIndexes;\n    }\n\n    get noGroupsSortedIndexes(){\n        return this.filteredIndexes.sort( getSorter( this.getRowData, this.sortDataKey, this.sortDirection ) );\n    }\n\n    get groupsSortedIndexes(){\n        return this.flattenedGroups.rowIndexes;\n    }\n\n    get hasGrouping(){\n        return !!this.groupKeys.length;\n    }\n\n    get finalIndexes(){\n        return this.hasGrouping ? this.groupsSortedIndexes : this.noGroupsSortedIndexes;\n    }\n\n    constructor(){\n        makeAutoObservable( this, {\n            shallowGroupsStore: false,\n            groupedSorted: computed({ equals: () => false }),\n            groupsSortedIndexes: computed({ equals: () => false }),\n            noGroupsSortedIndexes: computed({ equals: () => false }),\n            finalIndexes: computed({ equals: () => false }),\n            filteredIndexes: computed({ equals: () => false }),\n            orderedIndexes: computed({ equals: () => false })\n        });\n    }\n\n    merge( propertiesObj ){\n        Object.assign( this, propertiesObj );\n    }\n}\n\nexport default RowsAggregator;","// extracted by mini-css-extract-plugin\nexport default {\"sortableHeader\":\"_3xhCMieeqyydLLrsB_Rjwr\",\"input\":\"_7PdTV3zpJzO5l3JPCJbaz\"};","import { useState, useEffect } from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport RowsAggregator from \"models/RowsAggregator\";\nimport Table from \"../Table\";\nimport cx from \"utils/cx\";\nimport css from \"./style.module.scss\";\n\nconst HeaderLabel = observer(({ m, dataKey, label }) => (\n    <div\n        className={css.sortableHeader}\n        onClick={ e => e.ctrlKey ? m.addGrouping( dataKey ) : m.setSorting( dataKey )}\n        aria-sort={m.sortDataKey === dataKey?(m.sortDirection===1?\"ascending\":\"descending\"):undefined}\n    >\n        {label}\n    </div>\n));\n\nconst HeaderInput = observer(({ m, dataKey }) => (\n    <input\n        className={css.input}\n        value={m.filtersMap.get( dataKey )||\"\"}\n        onChange={e => m.setFiltering( dataKey, e.target.value )}\n    />\n));\n\nconst ComplexTable = ({ rowsQuantity, getRowData, className, ...props }) => {\n\n    const [ m ] = useState(() => new RowsAggregator());\n\n    const { finalIndexes } = m;\n\n    const renderRow = ( rowIndex, columns, getRowData, renderCell, CellsList, Cell ) => {\n        const realRowIndex = finalIndexes[ rowIndex ];\n        return (\n            <tr key={realRowIndex}>\n                {realRowIndex < 0 ? (\n                    <td colSpan={columns.length}>{realRowIndex}&nbsp;{m.flattenedGroups.groupValues[~realRowIndex]}</td>\n                ) : (\n                    <CellsList\n                        rowIndex={realRowIndex}\n                        columns={columns}\n                        getRowData={getRowData}\n                        renderCell={renderCell}\n                        Cell={Cell}\n                    />\n                )}\n            </tr>\n        );\n    }\n\n    const renderTheadContents = columns => (\n        <tr>\n            {columns.map(({ dataKey, label }) => (\n                <th key={dataKey}>\n                    <HeaderLabel m={m} dataKey={dataKey} label={label} />\n                    <HeaderInput m={m} dataKey={dataKey} />\n                </th>\n            ))}\n        </tr>        \n    );\n\n    useEffect(() => m.merge({ rowsQuantity, getRowData }));\n\n    return (\n        <Table\n            rowsQuantity={finalIndexes.length}\n            getRowData={getRowData}\n            renderRow={renderRow}\n            renderTheadContents={renderTheadContents}\n            className={cx(css.wrapper,className)}\n            {...props}\n        />\n    );\n}\n\nexport default observer( ComplexTable );","import Table from  \"af-virtual-scroll/ComplexTable\";\nimport faker from \"faker\";\n\nconst rows = Array.from({ length: 10000 }, (v, i) => ({\n    i,\n    firstName: faker.name.firstName(),\n    lastName: faker.name.lastName(),\n    country: faker.address.country()\n}));\n\n/* Math.random is not the best option, because same rowIndex should produce same height */\nconst getPureRandomLineHeight = rowIndex => 20 + ( rowIndex % 53 ) + ( rowIndex % 87 );\n\nconst ComplexTable = () => (\n    <Table\n        rowsQuantity={rows.length}\n        getRowData={i => rows[ i ]}\n        estimatedRowHeight={30}\n        columns={[\n            {\n                dataKey: \"i\",\n                render: ( cellData, rowData, rowIndex ) => (\n                    <div style={{\n                        color: \"#000\",\n                        textAlign: \"center\",\n                        lineHeight: `${getPureRandomLineHeight(rowIndex)}px`,\n                        background: `hsl(${rowIndex*11%360},60%,60%)`\n                    }}>\n                        {cellData}\n                    </div>\n                )\n            },\n            \"firstName\",\n            \"lastName\",\n            \"country\"\n        ]}\n    />\n);\n\nexport default ComplexTable;"],"sourceRoot":""}