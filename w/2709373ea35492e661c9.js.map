{"version":3,"sources":["webpack://af-virtual-scroll/./src/utils/startCase/index.js","webpack://af-virtual-scroll/./src/components/Table/Rows/index.js","webpack://af-virtual-scroll/./src/components/Table/Colgroup/index.js","webpack://af-virtual-scroll/./src/components/Table/style.module.scss?eda3","webpack://af-virtual-scroll/./src/components/Table/index.js","webpack://af-virtual-scroll/./src/components/Table/renderers.js"],"names":["str","replace","x","toUpperCase","E","START_INDEX","END_INDEX","Rows","columns","renderRow","getRowData","renderCell","CellsList","Cell","useSubscription","API","startIndex","endIndex","result","i","push","memo","Colgroup","map","dataKey","background","border","width","style","Table","fixed","estimatedRowHeight","renderTheadContents","rowsQuantity","overscanRowsCount","headless","dataRef","className","props","rowsContainerNode","rowsContainerRef","useState","Store","useModel","FixedHeightsStore","VariableHeightsStore","normalizedVisibleColumns","useMemo","column","finalColumn","label","startCase","Context","value","ScrollContainer","cx","css","Scroller","as","ref","propTypes","defaultProps","commonDefaultProps","rowIndex","rowData","render","getEmptyCellData","format","cellData","undefined"],"mappings":"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","file":"2709373ea35492e661c9.js","sourcesContent":["const startCase = str => str.replace( /([a-z])([A-Z])/g, \"$1 $2\" ).replace( /\\b[a-z]/g, x => x.toUpperCase() );\n\nexport default startCase;","import { memo } from \"react\";\r\nimport useSubscription from \"hooks/useSubscription\";\r\nimport { START_INDEX, END_INDEX } from \"constants/events\";\r\n\r\nconst E = [ START_INDEX, END_INDEX ];\r\n\r\nconst Rows = ({ columns, renderRow, getRowData, renderCell, CellsList, Cell }) => useSubscription( API => {\r\n\r\n    const { startIndex, endIndex } = API;\r\n\r\n    const result = [];\r\n\r\n    for( let i = startIndex; i < endIndex; i++ ){\r\n        result.push( renderRow( i, columns, getRowData, renderCell, CellsList, Cell ) );\r\n    }\r\n\r\n    return result;\r\n}, E );\r\n\r\nexport default memo( Rows );","import { memo } from \"react\";\r\n\r\nconst Colgroup = ({ columns }) => (\r\n    <colgroup>\r\n        {columns.map(({ dataKey, background, border, width }) => (\r\n            <col\r\n                key={dataKey}\r\n                style={{\r\n                    width,\r\n                    background,\r\n                    border\r\n                }}\r\n            />\r\n        ))}\r\n    </colgroup>\r\n);\r\n\r\nexport default memo( Colgroup );","// extracted by mini-css-extract-plugin\nexport default {\"wrapper\":\"_3xHZ6hLxyHZ-v8LLU1YA7y\",\"bodyTable\":\"_3VNLkND9VRhxpdmzEGLiXt\"};","import { memo, useState, useMemo } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\n\r\nimport commonPropTypes from \"../common/propTypes\";\r\nimport commonDefaultProps from \"../common/defaultProps\";\r\n\r\nimport cx from \"utils/cx\";\r\nimport startCase from \"utils/startCase\";\r\n\r\nimport Context from \"Context\";\r\nimport useModel from \"hooks/useModel\";\r\n\r\nimport VariableHeightsStore from \"models/VariableSizeList\";\r\nimport FixedHeightsStore from \"models/FixedSizeList\";\r\n\r\nimport ScrollContainer from \"../common/ScrollContainer\";\r\nimport Scroller from \"../common/Scroller\";\r\n\r\nimport Rows from \"./Rows\";\r\nimport Colgroup from \"./Colgroup\";\r\n\r\nimport {\r\n    renderRow,\r\n    renderCell,\r\n    renderTheadContents,\r\n    CellsList,\r\n    Cell\r\n} from \"./renderers\";\r\n\r\nimport css from \"./style.module.scss\";\r\n\r\n/*\r\n    Todo:\r\n        * measure thead & tfoot heights in order to properly calculate available space for rows\r\n        * think about border-collapse offsetHeight issue ( maybe throw border-collapse )\r\n*/\r\n\r\nconst Table = ({\r\n    fixed,\r\n    estimatedRowHeight,\r\n    columns,\r\n    getRowData,\r\n    renderRow,\r\n    renderCell,\r\n    renderTheadContents,\r\n    CellsList,\r\n    Cell,\r\n    rowsQuantity,\r\n    overscanRowsCount,\r\n    headless,\r\n    dataRef,\r\n    className,\r\n    ...props\r\n}) => {\r\n\r\n    const [ rowsContainerNode, rowsContainerRef ] = useState();\r\n\r\n    const Store = useModel(\r\n        fixed ? FixedHeightsStore : VariableHeightsStore,\r\n        dataRef,\r\n        estimatedRowHeight,\r\n        overscanRowsCount,\r\n        rowsQuantity,\r\n        rowsContainerNode\r\n    );\r\n\r\n    const normalizedVisibleColumns = useMemo(() => columns.map( column => {\r\n        const finalColumn = typeof column === \"string\" ? { dataKey: column } : { ...column };\r\n\r\n        if( !finalColumn.label ){\r\n            finalColumn.label = startCase( finalColumn.dataKey );\r\n        }\r\n\r\n        return finalColumn;\r\n    }), [ columns ]);   \r\n    \r\n    return (\r\n        <Context.Provider value={Store}>\r\n            <ScrollContainer className={cx(css.wrapper,className)} {...props}>\r\n                <table className={css.bodyTable}>\r\n                    <Colgroup columns={normalizedVisibleColumns} />\r\n                    {headless?null:(\r\n                        <thead>\r\n                            {renderTheadContents(normalizedVisibleColumns)}\r\n                        </thead>\r\n                    )}\r\n                    <Scroller as=\"tbody\" />\r\n                    <tbody ref={rowsContainerRef}>\r\n                        <Rows\r\n                            columns={normalizedVisibleColumns}\r\n                            getRowData={getRowData}\r\n                            renderRow={renderRow}\r\n                            renderCell={renderCell}\r\n                            CellsList={CellsList}\r\n                            Cell={Cell}\r\n                        />\r\n                    </tbody>\r\n                </table>\r\n            </ScrollContainer>\r\n        </Context.Provider>\r\n    );\r\n}\r\n\r\nTable.propTypes = {\r\n    ...commonPropTypes,\r\n    columns: PropTypes.arrayOf(\r\n        PropTypes.oneOfType([\r\n            PropTypes.string,\r\n                PropTypes.shape({\r\n                // unique key for column\r\n                dataKey: PropTypes.string.isRequired,\r\n\r\n                // for details see CellComponent implementation\r\n                getEmptyCellData: PropTypes.func,\r\n                format: PropTypes.func,\r\n                render: PropTypes.func,\r\n                formatTotal: PropTypes.func,\r\n\r\n                visibility: PropTypes.oneOf([ \"visible\", \"hidden\" ]),\r\n\r\n                // column props, affecting colgroup > col tags\r\n                background: PropTypes.string,\r\n                border: PropTypes.string,\r\n                width: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),\r\n                CellComponent: PropTypes.elementType,\r\n                getCellExtraProps: PropTypes.func\r\n            })\r\n        ])\r\n    ).isRequired,\r\n\r\n    getRowData: PropTypes.func.isRequired,\r\n\r\n    /**\r\n     * @param {number} rowIndex\r\n     * @param {array} columns\r\n     * @param {function} getRowData\r\n     * @param {function} renderCell\r\n     * @param {React.Component} CellsList\r\n     * @param {React.Component} Cell\r\n     * @returns {any} one row element child. Fragments are not supported.\r\n     */\r\n    renderRow: PropTypes.func,\r\n\r\n    renderCell: PropTypes.func,\r\n    renderTheadContents: PropTypes.func,\r\n    CellsList: PropTypes.elementType,\r\n    Cell: PropTypes.elementType,\r\n\r\n    headless: PropTypes.bool,\r\n};\r\n\r\nTable.defaultProps = {\r\n    ...commonDefaultProps,\r\n    headless: false,\r\n\r\n    renderRow,\r\n    renderCell,\r\n    renderTheadContents,\r\n    CellsList,\r\n    Cell\r\n};\r\n\r\nexport default memo( Table );","/*\n    If all cells in a row would be completely empty - row can \"collapse\" short.\n    To prevent it we can fill it with &nbsp;\n*/\nconst DEFAULT_EMPTY_CELL_CONTENT = \"\\u00A0\";\n\nexport const renderRow = ( rowIndex, columns, getRowData, renderCell, CellsList, Cell ) => (\n    <tr key={rowIndex}>\n        <CellsList\n            rowIndex={rowIndex}\n            columns={columns}\n            getRowData={getRowData}\n            renderCell={renderCell}\n            Cell={Cell}\n        />\n    </tr>\n);\n\nexport const renderCell = ( rowData, rowIndex, column, Cell ) => (\n    <td key={column.dataKey}>\n        <Cell\n            rowData={rowData}\n            rowIndex={rowIndex}\n            column={column}\n        />\n    </td>\n);\n\nexport const renderTheadContents = columns => (\n    <tr>\n        {columns.map( column => (\n            <th key={column.dataKey}>\n                {column.label}\n            </th>\n        ))}\n    </tr>\n);\n\nexport const CellsList = ({ rowIndex, columns, getRowData, renderCell, Cell }) => {\n    const rowData = getRowData( rowIndex );\n    return columns.map( column => renderCell( rowData, rowIndex, column, Cell ));\n}\n\nexport const Cell = ({ rowData, rowIndex, column }) => {\n    const { render, getEmptyCellData, dataKey, format } = column;\n\n    let cellData = rowData && rowData[ dataKey ];\n    \n    if( cellData === undefined || cellData === \"\" ){\n        cellData = getEmptyCellData ? getEmptyCellData( rowIndex, column ) : DEFAULT_EMPTY_CELL_CONTENT;\n    }\n    else{\n        if( format ){\n            cellData = format( cellData, rowData );\n        }\n        if( render ){\n            cellData = render( cellData, rowData, rowIndex, column );\n        }\n    }\n\n    return cellData;\n}"],"sourceRoot":""}