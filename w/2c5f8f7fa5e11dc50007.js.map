{"version":3,"sources":["webpack://af-virtual-scroll/./src/models/RowsAggregator/utils/multiGroupBy/index.js","webpack://af-virtual-scroll/./src/models/RowsAggregator/utils/getSorter/index.js","webpack://af-virtual-scroll/./src/models/RowsAggregator/utils/sortGroups/index.js","webpack://af-virtual-scroll/./src/models/RowsAggregator/utils/flattenGroups/index.js","webpack://af-virtual-scroll/./src/models/RowsAggregator/index.js","webpack://af-virtual-scroll/./src/components/ComplexTable/style.module.scss?b8c6","webpack://af-virtual-scroll/./src/components/ComplexTable/index.js","webpack://af-virtual-scroll/./src/examples/complexTable(unstable)/basic/index.js"],"names":["indexesArray","groupDataKeysList","getRowData","priorityGroupValuesArray","lastGroupIndex","length","lastGroupDataKey","groupsMap","Map","rowIndex","row","tmpInnerObject","cellValue","innerObject","i","get","priorityValue","has","set","push","sortDataKey","sortDirection","a","b","row1","row2","v1","v2","sortGroups","depth","currentDepth","groupValues","values","group","sortCallback","getSorter","sort","flattenGroups","collapsedGroups","prefix","rowIndexes","idx","groupValue","subGroup","concatenated","concat","Array","isArray","apply","this","columns","map","normalizeTableColumn","normalizedColumns","filter","col","groupKeys","includes","dataKey","find","c","priorityGroupValues","setFiltering","value","filtersMap","toLowerCase","delete","toggleCompact","compact","setSorting","setGrouping","dataKeysArray","addGrouping","clear","toggleCollapsedGroup","add","removeGrouping","indexOf","splice","from","rowsQuantity","v","multiGroupBy","filteredIndexes","grouped","groupedSorted","orderedIndexes","size","flattenedGroups","hasGrouping","groupsSortedIndexes","noGroupsSortedIndexes","constructor","Set","makeAutoObservable","computed","equals","comparer","visibleColumns","finalIndexes","merge","propertiesObj","Object","assign","HeaderLabel","observer","m","label","collectedProps","dragRef","useDrag","item","type","ref","className","css","onClick","onDoubleClick","e","ctrlKey","aria-sort","undefined","HeaderInput","onChange","target","getCount","total","nested","getSum","j","SummaryCell","column","totals","sum","fn","formatTotal","format","GroupsPanel","dropRef","useDrop","accept","drop","groupKey","GroupCell","isCollapsed","groupPath","getGroupName","Fragment","data-collapsed","style","marginLeft","path","reduce","res","key","ComplexTable","props","useState","RowsAggregator","useEffect","initialGroupingKeys","slice","initialGrouingIndex","initialGroupingIndex","DndProvider","backend","HTML5Backend","cx","Table","renderRow","RowProps","realRowIndex","index","colSpan","Row","renderHeaderCells","renderFooter","normalizedVisibleColumns","some","rows","fixedRange","firstName","faker","lastName","country","getPureRandomLineHeight","estimatedRowHeight","render","cellData","rowData","color","textAlign","lineHeight","background"],"mappings":"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","file":"2c5f8f7fa5e11dc50007.js","sourcesContent":["const multiGroupBy = ( indexesArray, groupDataKeysList, getRowData, priorityGroupValuesArray ) => {\n\n    const lastGroupIndex = groupDataKeysList.length - 1;\n\n    if( process.env.NODE_ENV !== \"production\" ){\n        if( lastGroupIndex < 0 ){\n            throw new Error( \"lastGroupIndex < 0\" );\n        }\n    }\n\n    const lastGroupDataKey = groupDataKeysList[ lastGroupIndex ];\n    const groupsMap = new Map();\n   \n\n    for( let rowIndex of indexesArray ){\n        /*\n            It is better to start from indexes iteration, not from groups, to minimize getRowData calls\n        */\n        const row = getRowData( rowIndex );\n\n        let innerObject = groupsMap,\n            tmpInnerObject,\n            cellValue;\n\n        /*\n            We could put everything in one loop, but last iteration is different.\n        */\n        for( let i = 0; i < lastGroupIndex; i++ ){\n            cellValue = row[ groupDataKeysList[ i ] ];\n            tmpInnerObject = innerObject.get( cellValue );\n            if( !tmpInnerObject ){\n                tmpInnerObject = new Map();\n                for( let priorityValue of priorityGroupValuesArray[ i ] ){\n                    if( !innerObject.has( priorityValue ) ){\n                        innerObject.set( priorityValue, null );\n                    }\n                }\n                innerObject.set( cellValue, tmpInnerObject );\n            }\n            innerObject = tmpInnerObject;\n        }\n\n        cellValue = row[ lastGroupDataKey ];\n        tmpInnerObject = innerObject.get( cellValue );\n\n        if( tmpInnerObject ){\n            tmpInnerObject.push( rowIndex );\n        }\n        else {\n            for( let priorityValue of priorityGroupValuesArray[ lastGroupIndex ] ){\n                if( !innerObject.has( priorityValue  ) ){\n                    innerObject.set( priorityValue, null );\n                }\n            }\n            innerObject.set( cellValue, [ rowIndex ]);\n        }\n    }\n\n    return groupsMap;\n}\n\nexport default multiGroupBy;","const getSorter = ( getRowData, sortDataKey, sortDirection ) => ( a, b ) => {\n    const row1 = getRowData( a );\n    const row2 = getRowData( b );\n\n    if( row1 && row2 ){\n        const v1 = row1[ sortDataKey ];\n        const v2 = row2[ sortDataKey ];\n        return v1 > v2 ? sortDirection : v1 < v2 ? -sortDirection : 0;\n    }\n\n    return row1 ? sortDirection : row2 ? -sortDirection : 0;\n}\n\nexport default getSorter;","import getSorter from \"../getSorter\";\n\nconst sortGroups = ( groupsMap, getRowData, sortDataKey, sortDirection, depth, currentDepth = 0 ) => {\n\n    const groupValues = groupsMap.values();\n\n    if( currentDepth < depth - 1 ){\n        for( let group of groupValues ){\n            if( group ){\n                sortGroups( group, getRowData, sortDataKey, sortDirection, depth, currentDepth + 1 );\n            }\n        }\n    }\n    else{\n        const sortCallback = getSorter( getRowData, sortDataKey, sortDirection );\n\n        for( let group of groupValues ){\n            if( group ){\n                group.sort( sortCallback );\n            }\n        }\n    }\n}\n\nexport default sortGroups;","const flattenGroups = ( groupsMap, collapsedGroups, prefix = [], groupValues = [], rowIndexes = [] ) => {\n    let idx;\n    for( let [ groupValue, subGroup ] of groupsMap ){\n        if( subGroup ){\n            const concatenated = prefix.concat( groupValue );\n            idx = -groupValues.push( concatenated );\n            rowIndexes.push( idx );\n            if( !collapsedGroups.has( idx ) ){\n                if( Array.isArray( subGroup ) ){\n                    rowIndexes.push.apply( rowIndexes, subGroup );\n                }\n                else{\n                    flattenGroups( subGroup, collapsedGroups, concatenated, groupValues, rowIndexes );\n                }\n            }\n        }\n    }\n\n    return { groupValues, rowIndexes };\n}\n\nexport default flattenGroups;","import { makeAutoObservable, comparer, computed } from \"mobx\"; \nimport multiGroupBy from \"./utils/multiGroupBy\";\nimport sortGroups from \"./utils/sortGroups\";\nimport flattenGroups from \"./utils/flattenGroups\";\nimport getSorter from \"./utils/getSorter\";\nimport normalizeTableColumn from \"utils/normalizeTableColumn\";\n\nclass RowsAggregator {\n\n    /* Provided from renderer */\n    rowsQuantity = 0;\n    getRowData = null;\n    columns = [];\n    compact = true;\n\n    /* Calculated inside model */\n    filtersMap = new Map();\n    groupKeys = [];\n    sortDataKey = \"\";\n    sortDirection = -1;\n\n    collapsedGroups = new Set();\n\n    get normalizedColumns(){\n        return this.columns.map( normalizeTableColumn );\n    }\n\n    get visibleColumns(){\n        return this.normalizedColumns.filter( col => !this.groupKeys.includes( col.dataKey ) );\n    }\n\n    get priorityGroupValuesArray(){\n        return this.groupKeys.map( dataKey => this.normalizedColumns.find( c => c.dataKey === dataKey ).priorityGroupValues || [] );\n    }\n\n    setFiltering( dataKey, value ){\n        if( value ){\n            this.filtersMap.set( dataKey, value.toLowerCase() );\n        }\n        else{\n            this.filtersMap.delete( dataKey );\n        }\n    }\n\n    toggleCompact(){\n        this.compact = !this.compact;\n    }\n\n    setSorting( dataKey ){\n        if( this.sortDataKey === dataKey ){\n            this.sortDirection *= -1;\n        }\n        this.sortDataKey = dataKey;\n    }\n\n    setGrouping( dataKeysArray ){\n        this.groupKeys = dataKeysArray;\n    }\n\n    addGrouping( dataKey ){\n        if( !this.groupKeys.includes( dataKey ) ){\n            this.groupKeys.push( dataKey );\n            this.collapsedGroups.clear();\n        }\n    }\n\n    toggleCollapsedGroup( idx ){\n        if( this.collapsedGroups.has( idx ) ){\n            this.collapsedGroups.delete( idx );\n        }\n        else{\n            this.collapsedGroups.add( idx );\n        }\n    }\n\n    removeGrouping( dataKey ){\n        const idx = this.groupKeys.indexOf( dataKey );\n        if( idx !== -1 ){\n            this.groupKeys.splice( idx, 1 );\n            this.collapsedGroups.clear();\n        }\n    }\n\n    get orderedIndexes(){\n        return Array.from({ length: this.rowsQuantity }, ( v, i ) => i );\n    }\n\n    get grouped(){\n        return multiGroupBy( this.filteredIndexes, this.groupKeys, this.getRowData, this.priorityGroupValuesArray );\n    }\n\n    get groupedSorted(){\n        if( this.sortDataKey ){\n            sortGroups( this.grouped, this.getRowData, this.sortDataKey, this.sortDirection, this.groupKeys.length );\n        }\n        return this.grouped;\n    }\n\n    get flattenedGroups(){\n        return flattenGroups( this.groupedSorted, this.collapsedGroups );\n    }\n\n    get filteredIndexes(){\n        const { filtersMap, orderedIndexes } = this;\n        if( this.filtersMap.size ){\n            const filteredIndexesArray = orderedIndexes.filter( idx => {\n                const row = this.getRowData( idx );\n                for( let [ dataKey, value ] of filtersMap ){\n                    if( !( \"\" + row[ dataKey ] ).toLowerCase().includes( value ) ){\n                        return false;\n                    }\n                }\n                return true;\n            });\n\n            return filteredIndexesArray;\n        }\n        return orderedIndexes;\n    }\n\n    \n    get noGroupsSortedIndexes(){\n        return this.sortDataKey ? this.filteredIndexes.sort( getSorter( this.getRowData, this.sortDataKey, this.sortDirection ) ) : this.filteredIndexes;\n    }\n\n    get groupsSortedIndexes(){\n        return this.flattenedGroups.rowIndexes;\n    }\n\n    get hasGrouping(){\n        return !!this.groupKeys.length;\n    }\n\n    get finalIndexes(){\n        return this.hasGrouping ? this.groupsSortedIndexes : this.noGroupsSortedIndexes;\n    }\n\n    constructor(){\n        makeAutoObservable( this, {\n            normalizedColumns: computed({ equals: comparer.structural }),\n            visibleColumns: computed({ equals: comparer.structural }),\n            priorityGroupValuesArray: computed({ equals: comparer.structural }),\n            groupedSorted: computed({ equals: () => false }),\n            groupsSortedIndexes: computed({ equals: () => false }),\n            noGroupsSortedIndexes: computed({ equals: () => false }),\n            finalIndexes: computed({ equals: () => false }),\n            filteredIndexes: computed({ equals: () => false }),\n            orderedIndexes: computed({ equals: () => false })\n        });\n    }\n\n    merge( propertiesObj ){\n        Object.assign( this, propertiesObj );\n    }\n}\n\nexport default RowsAggregator;","// extracted by mini-css-extract-plugin\nexport default {\"wrapper\":\"_2B3KY_2EhDdLzl3od9PxI3\",\"sortableHeader\":\"_3xhCMieeqyydLLrsB_Rjwr\",\"input\":\"_7PdTV3zpJzO5l3JPCJbaz\",\"groupsPanel\":\"_24CQvBWd2KIxalcwIBcG6S\",\"groupLabel\":\"_1Pfh0g4BE_cuNHu46ByRkY\",\"groupToggler\":\"_2t1GlnfqduCsfI_X7Q0BSx\",\"columnSummaries\":\"QsUrLMXUKybinaPXO0z0B\"};","import { Fragment, useState, useEffect } from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport RowsAggregator from \"models/RowsAggregator\";\nimport Table from \"../Table\";\nimport cx from \"utils/cx\";\nimport css from \"./style.module.scss\";\nimport { HTML5Backend } from \"react-dnd-html5-backend\";\nimport { useDrag, useDrop, DndProvider } from \"react-dnd\";\n\nconst HEADER_DND_TYPE = \"h\";\n\nconst HeaderLabel = /*#__PURE__*/ observer(({ m, dataKey, label }) => {\n\n    const [ collectedProps, dragRef ] = useDrag({ item: {\n        type: HEADER_DND_TYPE,\n        dataKey\n    }});\n\n    return (\n        <div\n            ref={dragRef}\n            className={css.sortableHeader}\n            onClick={() => m.setSorting( dataKey )}\n            onDoubleClick={ e => e.ctrlKey && m.toggleCompact()}\n            aria-sort={m.sortDataKey === dataKey?(m.sortDirection===1?\"ascending\":\"descending\"):undefined}\n        >\n            {label}\n        </div>\n    );\n});\n\nconst HeaderInput = /*#__PURE__*/ observer(({ m, dataKey }) => m.compact ? null : (\n    <input\n        className={css.input}\n        value={m.filtersMap.get( dataKey )||\"\"}\n        onChange={e => m.setFiltering( dataKey, e.target.value )}\n    />\n));\n\nconst getCount = rowIndexes => {\n\n    let total = 0;\n\n    if( Array.isArray( rowIndexes ) ){\n        total += rowIndexes.length;\n    }\n    else {\n        for( let nested of rowIndexes.values() ){\n            if( nested ){\n                total += getCount( nested );\n            }\n        }\n    }\n\n    return total;\n}\n\nconst getSum = ( rowIndexes, dataKey, getRowData ) => {\n\n    let total = 0;\n\n    if( Array.isArray( rowIndexes ) ){\n        let row;\n        for( let j of rowIndexes ){\n            row = getRowData( j );\n            total += row[ dataKey ];\n        }\n    }\n    else {\n        for( let nested of rowIndexes.values() ){\n            if( nested ){\n                total += getSum( nested, dataKey, getRowData );\n            }\n        }\n    }\n\n    return total;\n}\n\nconst SummaryCell = /*#__PURE__*/ observer(({ m, column, rowIndexes }) => {\n\n    if( column.totals === \"count\" ){\n        return getCount( rowIndexes );\n    }\n\n    if( column.totals === \"sum\" ){\n        const sum = getSum( rowIndexes, column.dataKey, m.getRowData );\n        const fn = column.formatTotal || column.format;\n        return fn ? fn( sum ) : sum;\n    }\n\n    return null;\n});\n\nconst GroupsPanel = /*#__PURE__*/ observer(({ m }) => {\n\n    const [ collectedProps, dropRef ] = useDrop({\n        accept: HEADER_DND_TYPE,\n        drop( item ){\n            m.addGrouping( item.dataKey );\n        }\n    });\n\n    return m.compact ? null : (\n        <div className={css.groupsPanel} ref={dropRef}>\n            {m.groupKeys.length ? m.groupKeys.map( groupKey => (\n                <div className={css.groupLabel} key={groupKey} onDoubleClick={() => m.removeGrouping( groupKey )}>\n                    {groupKey}\n                </div>\n            )) : \"Drag column headers here to group by column\" }\n        </div>\n    );\n});\n\nconst getInMap = ( map, path ) => path.reduce(( res, key ) => res.get( key ), map );\n\nconst GroupCell = /*#__PURE__*/ observer(({ m, columns, idx }) => {\n\n    const isCollapsed = m.collapsedGroups.has( idx );\n\n    if( m.hasGrouping ){\n\n        const groupPath = m.flattenedGroups.groupValues[~idx];\n\n        if( groupPath ){\n\n            const lastGroupIndex = groupPath.length - 1;\n            const groupKey = m.groupKeys[lastGroupIndex];\n            /* hidden columns also must be included */\n            const { getGroupName, label } = m.normalizedColumns.find( c => c.dataKey === groupKey );\n            const groupValue = groupPath[lastGroupIndex];\n\n            return (\n                <Fragment>\n                    <span\n                        className={css.groupToggler}\n                        onClick={() => m.toggleCollapsedGroup( idx )}\n                        data-collapsed={isCollapsed?\"\":undefined}\n                        style={{\n                            marginLeft: `${(lastGroupIndex)*2}em`\n                        }}\n                    />\n                    &nbsp;\n                    {getGroupName?getGroupName(groupValue):label}:&nbsp;{\"\"+groupValue}\n                    {columns.length ? (\n                        <span className={css.columnSummaries}>\n                            {columns.map( col => col.totals ? (\n                                <span key={col.dataKey}>\n                                    {col.label}:\n                                    &nbsp;\n                                    <SummaryCell\n                                        m={m}\n                                        column={col}\n                                        rowIndexes={getInMap(m.grouped,groupPath)}\n                                    />\n                                </span>\n                            ) : null)}\n                        </span>\n                    ) : null}\n                </Fragment>\n            );\n        }\n        \n    }\n\n    return null;\n});\n\nconst ComplexTable = ({ rowsQuantity, getRowData, className, columns, ...props }) => {\n\n    const [ m ] = useState(() => new RowsAggregator());\n\n    const { finalIndexes } = m;\n\n    const renderRow = RowProps => {\n\n        const realRowIndex = finalIndexes[ RowProps.index ];\n\n        return realRowIndex < 0 ? (\n            <tr key={RowProps.index}>\n                <td colSpan={RowProps.columns.length}>\n                    <GroupCell m={m} idx={realRowIndex} columns={RowProps.columns} />\n                </td>\n            </tr>\n        ) : (\n            <RowProps.Row\n                {...RowProps}\n                key={RowProps.index}\n                index={realRowIndex}\n            />\n        );\n    }\n\n    const renderHeaderCells = columns => columns.map(({ dataKey, label }) => (\n        <th key={dataKey}>\n            <HeaderLabel m={m} dataKey={dataKey} label={label} />\n            <HeaderInput m={m} dataKey={dataKey} />\n        </th>\n    ));\n\n    useEffect(() => m.merge({ rowsQuantity, getRowData, columns }));\n\n    useEffect(() => {\n        const initialGroupingKeys = m.visibleColumns\n            .slice()\n            .sort(( a, b ) => ( a.initialGrouingIndex || 0 ) - ( b.initialGrouingIndex || 0 ) )\n            .filter( col => col.initialGroupingIndex )\n            .map( col => col.dataKey );\n\n        m.setGrouping( initialGroupingKeys );\n    }, []);\n\n    const renderFooter = normalizedVisibleColumns => normalizedVisibleColumns.some( col => !!col.totals ) ? (\n        <tfoot>\n            <tr>\n                {normalizedVisibleColumns.map( col => (\n                    <td key={col.dataKey}>\n                        <SummaryCell m={m} column={col} rowIndexes={m.filteredIndexes} />\n                    </td>\n                ))}\n            </tr>\n        </tfoot>\n    ) : null;\n\n    return (\n        <DndProvider backend={HTML5Backend}>\n            <div className={cx(css.wrapper,className)}>\n                <GroupsPanel m={m} />\n                <Table\n                    columns={m.visibleColumns}\n                    rowsQuantity={finalIndexes.length}\n                    getRowData={getRowData}\n                    renderRow={renderRow}\n                    renderHeaderCells={renderHeaderCells}\n                    renderFooter={renderFooter}\n                    {...props}\n                />\n            </div>\n        </DndProvider> \n    );\n}\n\nexport default /*#__PURE__*/ observer( ComplexTable );","import { ComplexTable as Table } from  \"af-virtual-scroll\";\nimport faker from \"faker\";\n\nconst rows = Array.from({ length: 10000 }, (v, i) => ({\n    i,\n    fixedRange: i % 9,\n    firstName: faker.name.firstName(),\n    lastName: faker.name.lastName(),\n    country: faker.address.country()\n}));\n\n/* Math.random is not the best option, because same rowIndex should produce same height */\nconst getPureRandomLineHeight = rowIndex => 20 + ( rowIndex % 53 ) + ( rowIndex % 87 );\n\nconst ComplexTable = () => (\n    <Table\n        rowsQuantity={rows.length}\n        getRowData={i => rows[ i ]}\n        estimatedRowHeight={30}\n        columns={[\n            {\n                dataKey: \"i\",\n                totals: \"sum\",\n                render: ( cellData, rowData, rowIndex ) => (\n                    <div style={{\n                        color: \"#000\",\n                        textAlign: \"center\",\n                        lineHeight: `${getPureRandomLineHeight(rowIndex)}px`,\n                        background: `hsl(${rowIndex*11%360},60%,60%)`\n                    }}>\n                        {cellData}\n                    </div>\n                )\n            },\n            {\n                dataKey: \"fixedRange\",\n                initialGroupingIndex: 1,\n                priorityGroupValues: [ 4, 7, 71, 5 ]\n            },\n            {\n                dataKey: \"firstName\",\n                initialGroupingIndex: 2,\n                priorityGroupValues: [ \"Dennis\" ],\n                totals: \"count\"\n            },\n            \"lastName\",\n            \"country\"\n        ]}\n    />\n);\n\nexport default ComplexTable;"],"sourceRoot":""}