{"version":3,"sources":["webpack://af-virtual-scroll/./src/Context.js","webpack://af-virtual-scroll/./src/components/common/HeightProvider/style.module.scss?9ac1","webpack://af-virtual-scroll/./src/components/common/HeightProvider/index.js","webpack://af-virtual-scroll/./src/components/common/ScrollContainer/style.module.scss?e713","webpack://af-virtual-scroll/./src/components/common/ScrollContainer/index.js","webpack://af-virtual-scroll/./src/components/common/Scroller/style.module.scss?e791","webpack://af-virtual-scroll/./src/components/common/Scroller/index.js","webpack://af-virtual-scroll/./src/constants/events.js","webpack://af-virtual-scroll/./src/hooks/useApi/index.js","webpack://af-virtual-scroll/./src/hooks/useModel/index.js","webpack://af-virtual-scroll/./src/hooks/useForceUpdate/index.js","webpack://af-virtual-scroll/./src/hooks/useSubscription/index.js","webpack://af-virtual-scroll/./src/models/FixedSizeList/index.js","webpack://af-virtual-scroll/./src/models/PubSub/index.js","webpack://af-virtual-scroll/./src/models/ListBase/index.js","webpack://af-virtual-scroll/./src/models/VariableSizeList/index.js","webpack://af-virtual-scroll/./src/utils/cx/index.js","webpack://af-virtual-scroll/./src/utils/throttle/index.js"],"names":["createContext","E","WIDGET_SCROLL_HEIGHT","useSubscription","API","aria-hidden","className","css","style","height","widgetScrollHeight","ScrollContainer","children","props","ref","useRef","useApi","useEffect","el","current","setScrollContainerNode","R","ResizeObserver","entries","length","width","contentRect","setWidgetDimensions","Math","round","observe","unobserve","tabIndex","cx","onScroll","e","setScrollTop","target","scrollTop","memo","VIRTUAL_TOP_OFFSET","as","Component","virtualTopOffset","START_INDEX","END_INDEX","SCROLL_TOP","ROWS_QUANTITY","OVERSCAN_ROWS_COUNT","WIDGET_WIDTH","WIDGET_HEIGHT","ROWS_CONTAINER_NODE","CACHED_ROWS_HEIGHT","EVENTS_ARRAY_LENGTH","useContext","Context","StoreConstructor","dataRef","estimatedRowHeight","overscanRowsCount","rowsQuantity","rowsContainerNode","finalDataRef","Store","startBatch","setViewParams","endBatch","destructor","increment","x","useReducer","callBack","events","prevRenrerRef","forceUpdate","useForceUpdate","on","off","inBatch","queue","FixedSizeList","ListBase","setRowHeight","v","this","rowHeight","emit","constructor","super","updateRowHeightThrottled","throttle","updateRowHeight","cancel","getIndex","offset","floor","getOffset","index","widgetWidth","widgetHeight","firstElementChild","offsetHeight","_E","Array","from","_Q","Set","_on","shouldPrepend","fn","prototype","unshift","push","evt","call","prependListener","splice","clear","indexOf","cb","add","PubSub","node","scrollContainerNode","startIndex","endIndex","updateWidgetScrollHeight","updateStartIndex","updateEndIndex","updateVirtualTopOffset","scrollToRow","rowIndex","max","min","VariableSizeList","rowHeights","fTree","msb","updateRowHeightsThrottled","updateRowHeights","grow","updateMsb","clz32","curRowHeighsLength","oldRowHeights","Uint32Array","set","fill","j","i","resetCachedHeights","tempIndex","bitMask","result","delta","diff","cacheChanged","child","baseClass","extraClass","ms","ctx","timer","invoke","throttled","setTimeout","clearTimeout"],"mappings":"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","file":"d61af7e800235cb3580e.js","sourcesContent":["import { createContext } from \"react\";\r\n\r\nexport default createContext();","// extracted by mini-css-extract-plugin\nexport default {\"wrapper\":\"a2uMg3Zj4kpPT6J8EoqLx\"};","import useSubscription from \"hooks/useSubscription\";\nimport css from \"./style.module.scss\";\nimport { WIDGET_SCROLL_HEIGHT } from \"constants/events\";\n\nconst E = [ WIDGET_SCROLL_HEIGHT ];\n\nconst HeightProvider = () => useSubscription( API => (\n    <div\n        aria-hidden=\"true\"\n        className={css.wrapper}\n        style={{ height: API.widgetScrollHeight }}\n    />\n), E );\n\nexport default HeightProvider","// extracted by mini-css-extract-plugin\nexport default {\"wrapper\":\"_3Jl24WrVf4wfsfDMBe4LVm\"};","import { useRef, memo, useEffect } from \"react\";\r\nimport cx from \"utils/cx\";\r\nimport useApi from \"hooks/useApi\";\r\nimport HeightProvider from \"../HeightProvider\";\r\nimport css from \"./style.module.scss\";\r\n\r\nconst ScrollContainer = ({ className, children, ...props }) => {\r\n\r\n    const ref = useRef();\r\n    const API = useApi();\r\n\r\n    useEffect(() => {\r\n        const el = ref.current;\r\n\r\n        API.setScrollContainerNode( el );\r\n\r\n        const R = new ResizeObserver( entries => {\r\n            if( entries.length === 1 ){\r\n                const { width, height } = entries[ 0 ].contentRect;\r\n                API.setWidgetDimensions( Math.round( width ), Math.round( height ) );\r\n            }\r\n        });\r\n\r\n        R.observe( el );\r\n\r\n        return () => R.unobserve( el );\r\n    }, []);\r\n    \r\n    /*\r\n        tabIndex=\"0\" is for proper keyboard nav\r\n        https://bugzilla.mozilla.org/show_bug.cgi?id=1346159\r\n    */\r\n    return (\r\n        <div\r\n            {...props}\r\n            ref={ref}\r\n            tabIndex=\"0\"\r\n            className={cx(css.wrapper,className)}\r\n            ref={ref}\r\n            onScroll={e => API.setScrollTop( e.target.scrollTop )}\r\n        >\r\n            <HeightProvider />\r\n            {children}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default memo( ScrollContainer );","// extracted by mini-css-extract-plugin\nexport default {\"wrapper\":\"_1HtCuT_dRO5NkFdxciGGTx\"};","import css from \"./style.module.scss\";\r\nimport useSubscription from \"hooks/useSubscription\";\r\nimport { VIRTUAL_TOP_OFFSET } from \"constants/events\";\r\n\r\nconst E = [ VIRTUAL_TOP_OFFSET ];\r\n\r\n/*\r\n    Hmm, I can't put here more than ~ 3 000 000. Maybe need to put one more row in case this height is > 3 000 000\r\n*/\r\nconst Scroller = ({ as: Component }) => useSubscription( API => (\r\n    <Component\r\n        className={css.wrapper}\r\n        aria-hidden=\"true\"\r\n        style={{ height: API.virtualTopOffset }}\r\n    />\r\n), E );\r\n\r\nexport default Scroller;","export const START_INDEX                = 0;\nexport const END_INDEX                  = 1;\nexport const SCROLL_TOP                 = 2;\nexport const ROWS_QUANTITY              = 3;\nexport const OVERSCAN_ROWS_COUNT        = 4;\nexport const WIDGET_WIDTH               = 5;\nexport const WIDGET_HEIGHT              = 6;\nexport const VIRTUAL_TOP_OFFSET         = 7;\nexport const WIDGET_SCROLL_HEIGHT       = 8;\nexport const ROWS_CONTAINER_NODE        = 9;\nexport const CACHED_ROWS_HEIGHT         = 10;\n\nexport const EVENTS_ARRAY_LENGTH        = 11;","import { useContext } from \"react\";\nimport Context from \"../../Context\";\n\nconst useApi = () => useContext( Context );\n\nexport default useApi;","import { useRef, useEffect } from \"react\";\n\n/*\n    dataRef is to call Data methods from outside( Data.scrollTo(), etc. ).\n    As it is not dom-related, I decided to avoid forwardRef\n*/\nconst useStore = ( StoreConstructor, dataRef, estimatedRowHeight, overscanRowsCount, rowsQuantity, rowsContainerNode ) => {\n\n    const finalDataRef = useRef();\n\n    let Store = finalDataRef.current;\n\n    if( !( Store instanceof StoreConstructor ) ){\n        Store = finalDataRef.current = new StoreConstructor();\n    }\n\n    if( dataRef ){\n        dataRef.current = Store;\n    }\n\n    Store.startBatch().setViewParams( estimatedRowHeight, overscanRowsCount, rowsQuantity, rowsContainerNode );\n\n    useEffect(() => {\n        Store.endBatch();\n    });\n    \n    useEffect(() => () => Store.destructor(), [ Store ]);\n\n    return Store;\n};\n\nexport default useStore;","import { useReducer } from \"react\";\n\nconst increment = x => x + 1;\n\nconst useForceUpdate = () => useReducer( increment, 0 )[ 1 ];\n\nexport default useForceUpdate;","import { useRef, useEffect } from \"react\";\nimport useForceUpdate from \"../useForceUpdate\";\nimport useApi from \"../useApi\";\n\nconst useSubscription = ( callBack, events ) => {\n    \n    const prevRenrerRef = useRef( null );\n    const API = useApi();\n    const forceUpdate = useForceUpdate();\n    \n    useEffect(() => {\n        API.on( forceUpdate, ...events );\n        return () => API.off( forceUpdate, ...events );\n    }, events );\n\n    if( API.inBatch ){\n        /*\n            Somebody tried to rerender, while we were in batch.\n            On batch finish component definitely must be rerendered.\n        */\n        API.queue( forceUpdate );\n    }\n    else{\n        prevRenrerRef.current = callBack( API );\n    }\n    \n    return prevRenrerRef.current;\n}\n\nexport default useSubscription;","import ListBase from \"../ListBase\";\nimport throttle from \"utils/throttle\";\n\nimport {\n    START_INDEX,\n    END_INDEX,\n    SCROLL_TOP,\n    ROWS_QUANTITY,\n    OVERSCAN_ROWS_COUNT,\n    WIDGET_WIDTH,\n    WIDGET_HEIGHT,\n    VIRTUAL_TOP_OFFSET,\n    WIDGET_SCROLL_HEIGHT,\n    ROWS_CONTAINER_NODE,\n    CACHED_ROWS_HEIGHT,\n} from \"constants/events\";\n\nclass FixedSizeList extends ListBase {\n\n    rowHeight = 0;\n\n    setRowHeight( v ){\n        if( v !== this.rowHeight ){\n            this.rowHeight = v;\n            this.emit( CACHED_ROWS_HEIGHT );\n        }\n    }\n\n    constructor(){\n        super();\n\n        this.on( this.updateRowHeightThrottled, WIDGET_WIDTH, WIDGET_HEIGHT, ROWS_CONTAINER_NODE, ROWS_QUANTITY );\n    }\n\n    destructor(){\n        this.updateRowHeightThrottled.cancel();\n        super.destructor();\n    }\n\n    getIndex( offset ){\n        return this.rowHeight && Math.floor( offset / this.rowHeight );\n    }\n\n    getOffset( index ){\n        return index * this.rowHeight;\n    }\n\n    updateRowHeight(){\n        if( this.widgetWidth && this.widgetHeight && this.rowsContainerNode && this.rowsQuantity ){\n            const { firstElementChild } = this.rowsContainerNode;\n            if( firstElementChild ){\n                this.setRowHeight( firstElementChild.offsetHeight );\n            }\n        }\n        else {\n            this.setRowHeight( this.estimatedRowHeight );\n        }\n    }\n    \n    updateRowHeightThrottled = throttle( this.updateRowHeight, 200, this );\n}\n\nexport default FixedSizeList;","import { EVENTS_ARRAY_LENGTH } from \"constants/events\";\n\nclass PubSub {\n\n    /* All callbacks are known in advance, so we can allocate in construcror */\n    _E = Array.from({ length: EVENTS_ARRAY_LENGTH }, () => []);\n\n    /* query of callbacks, that should run after batch end */\n    _Q = new Set();\n\n    /* depth of batch */\n    inBatch = 0;\n\n    _on( callBack, events, shouldPrepend ){\n        const fn = shouldPrepend ? Array.prototype.unshift : Array.prototype.push;\n        for( let evt of events ){\n            fn.call( this._E[ evt ], callBack );\n        }\n        return this;\n    }\n\n    on( callBack, ...events ){\n        return this._on( callBack, events, false );\n    }\n\n    prependListener( callBack, ...events ){\n        return this._on( callBack, events, true );\n    }\n\n    destructor(){\n        for( let events of this._E ){\n            events.splice( 0 );\n        }\n        this._Q.clear();\n    }\n\n    off( callBack, ...events ){\n        for( let evt of events ){\n            this._E[ evt ].splice( this._E[ evt ].indexOf( callBack ) >>> 0, 1 );\n        }\n        return this;\n    }\n\n    queue( cb ){\n        if( process.env.NODE_ENV !== \"production\" ){\n            if( !this.inBatch ){\n                console.error( \"trying to add event to batch queue, while inBatch is 0\" );\n            }\n        }\n        this._Q.add( cb );\n    }\n\n    emit( evt ){\n        if( this.inBatch ){\n            for( let cb of this._E[ evt ] ){\n                this._Q.add( cb );\n            }\n        }\n        else{\n            for( let cb of this._E[ evt ] ){\n                cb.call( this );\n            }\n        }\n        return this;\n    }\n\n    /* inspired by mobx */\n\n    startBatch(){\n        this.inBatch++;\n        return this;\n    }\n\n    endBatch(){\n        if( !--this.inBatch ){\n            for( let cb of this._Q ){\n                cb.call( this );\n            }\n            this._Q.clear();\n        }\n        return this;\n    }\n}\n\nexport default PubSub;","import PubSub from \"../PubSub\";\n\nimport {\n    START_INDEX,\n    END_INDEX,\n    SCROLL_TOP,\n    ROWS_QUANTITY,\n    OVERSCAN_ROWS_COUNT,\n    WIDGET_WIDTH,\n    WIDGET_HEIGHT,\n    VIRTUAL_TOP_OFFSET,\n    WIDGET_SCROLL_HEIGHT,\n    ROWS_CONTAINER_NODE,\n    CACHED_ROWS_HEIGHT,\n} from \"constants/events\";\n\nclass ListBase extends PubSub {\n\n    /* Provided from renderer */\n    scrollTop = 0;\n    rowsQuantity = 0;\n    overscanRowsCount = 0;\n    widgetHeight = 0;\n    widgetWidth = 0;\n    estimatedRowHeight = 0;\n    rowsContainerNode = null;\n    scrollContainerNode = null;\n\n    setScrollContainerNode( node ){\n        this.scrollContainerNode = node;\n    }\n\n    setScrollTop( v ){\n        if( v !== this.scrollTop ){\n            this.scrollTop = v;\n            \n            this\n                .startBatch()\n                .emit( SCROLL_TOP )\n                .endBatch();\n        }\n    }\n\n    constructor(){\n        super()\n\n        this\n            .on( this.updateWidgetScrollHeight, CACHED_ROWS_HEIGHT, ROWS_QUANTITY )\n            .on( this.updateStartIndex, SCROLL_TOP, CACHED_ROWS_HEIGHT, OVERSCAN_ROWS_COUNT )\n            .on( this.updateEndIndex, ROWS_QUANTITY, SCROLL_TOP, WIDGET_HEIGHT, OVERSCAN_ROWS_COUNT, CACHED_ROWS_HEIGHT )\n            .on( this.updateVirtualTopOffset, START_INDEX, CACHED_ROWS_HEIGHT );\n    }\n\n    scrollToRow( rowIndex ){\n        if( this.scrollContainerNode ){\n            this.scrollContainerNode.scrollTop = this.getOffset( rowIndex );\n        }\n        else if( process.env.NODE_ENV !== \"production\" ){\n            console.error( \"scrollContainerNode is not set\" );\n        }\n    }\n\n    updateStartIndex(){\n        const v = Math.max( 0, this.getIndex( this.scrollTop ) - this.overscanRowsCount );\n        if( v !== this.startIndex ){\n            this.startIndex = v;\n            this.emit( START_INDEX );\n        }\n    }\n\n    updateEndIndex(){\n        const v = Math.min( this.rowsQuantity, this.getIndex( this.scrollTop + this.widgetHeight ) + this.overscanRowsCount );\n        if( v !== this.endIndex ){\n            this.endIndex = v;\n            this.emit( END_INDEX );\n        }\n    }\n\n    updateVirtualTopOffset(){\n        const v = this.getOffset( this.startIndex );\n        if( v !== this.virtualTopOffset ){\n            this.virtualTopOffset = v;\n            this.emit( VIRTUAL_TOP_OFFSET );\n        }\n    }\n\n    updateWidgetScrollHeight(){\n        const v = this.getOffset( this.rowsQuantity );\n        if( v !== this.widgetScrollHeight ){\n            this.widgetScrollHeight = v;\n            this.emit( WIDGET_SCROLL_HEIGHT );\n        }\n    }\n\n    setWidgetDimensions( width, height ){\n        this.startBatch();\n        if( width !== this.widgetWidth ){\n            this.widgetWidth = width;\n            this.emit( WIDGET_WIDTH );\n        }\n        if( height !== this.widgetHeight ){\n            this.widgetHeight = height;\n            this.emit( WIDGET_HEIGHT );\n        }\n        this.endBatch();\n    }\n\n    setViewParams( estimatedRowHeight, overscanRowsCount, rowsQuantity, rowsContainerNode ){\n\n        this.estimatedRowHeight = estimatedRowHeight;\n\n        this.startBatch();\n\n        if( overscanRowsCount !== this.overscanRowsCount ){\n            this.overscanRowsCount = overscanRowsCount;\n            this.emit( OVERSCAN_ROWS_COUNT );\n        }\n\n        if( rowsQuantity !== this.rowsQuantity ){\n            this.rowsQuantity = rowsQuantity;\n            this.emit( ROWS_QUANTITY );\n        }\n\n        if( rowsContainerNode !== this.rowsContainerNode ){\n            this.rowsContainerNode = rowsContainerNode;\n            this.emit( ROWS_CONTAINER_NODE );\n        }\n\n        this.endBatch();\n    }\n\n    /* Calculated inside model */\n    startIndex = 0;\n    endIndex = 0;\n    virtualTopOffset = 0;\n    widgetScrollHeight = 0;\n}\n\nexport default ListBase;","import ListBase from \"../ListBase\";\nimport throttle from \"utils/throttle\";\n\nimport {\n    ROWS_QUANTITY,\n    WIDGET_SCROLL_HEIGHT,\n    WIDGET_WIDTH,\n    START_INDEX,\n    END_INDEX,\n    ROWS_CONTAINER_NODE,\n    CACHED_ROWS_HEIGHT,\n} from \"constants/events\";\n\n/*\n    TODO:\n        when estimatedRowHeight is not correct, scroll behavior is weird here\n        perform resetCacheHeights from useEffect on rowRenderer change\n*/\n\nclass VariableSizeList extends ListBase {\n    \n    rowHeights = [];\n    fTree = [];\n\n    /*\n        most significant bit of this.rowsQuantity;\n        caching it to avoid Math.clz32 calculations on every getIndex call\n    */\n    msb = 0;\n    \n    constructor(){\n        super();\n\n        this\n            /* must be done before events, attached in ListBase */\n            .prependListener( this.grow, ROWS_QUANTITY )\n            .prependListener( this.updateMsb, ROWS_QUANTITY )\n            .on( this.updateRowHeightsThrottled, ROWS_CONTAINER_NODE, WIDGET_WIDTH, START_INDEX, END_INDEX );            \n    }\n\n    destructor(){\n        this.updateRowHeightsThrottled.cancel();\n        super.destructor();\n    }\n\n    updateMsb(){\n        this.msb = 1 << 31 - Math.clz32( this.rowsQuantity );\n    }\n\n    grow(){\n        const { rowsQuantity } = this;\n\n        const curRowHeighsLength = this.rowHeights.length;\n\n        if( rowsQuantity > curRowHeighsLength ){\n\n            const oldRowHeights = this.rowHeights;\n            \n            this.rowHeights = new Uint32Array( rowsQuantity );\n            this.fTree = new Uint32Array( rowsQuantity + 1 );\n\n            if( curRowHeighsLength ){\n                this.rowHeights.set( oldRowHeights );\n                this.rowHeights.fill( this.estimatedRowHeight, curRowHeighsLength );\n\n\n                /* \n                    Creating fenwick tree from an array in linear time;\n                    It is much more efficient, than calling updateRowHeight N times.\n                */\n\n                this.fTree.set( this.rowHeights, 1 );\n\n                for( let i = 1, j; i <= rowsQuantity; i++ ){\n                    j = i + ( i & -i );\n                    if( j <= rowsQuantity ){\n                        this.fTree[ j ] += this.fTree[ i ];\n                    }\n                }\n\n                this.emit( CACHED_ROWS_HEIGHT );\n            }\n            else {\n                this.resetCachedHeights();\n            }\n        }        \n    }\n\n    resetCachedHeights( rowHeight = this.estimatedRowHeight ){\n        this.rowHeights.fill( rowHeight );\n\n        /* Filling FenwickTee with single value  */\n        for ( let i = 1; i <= this.rowsQuantity; i++ ){\n            this.fTree[ i ] = rowHeight * ( i & -i );\n        }\n\n        this.emit( CACHED_ROWS_HEIGHT );\n    }\n\n    getIndex( offset ){\n        let index = 0;\n        \n        for( let bitMask = this.msb, tempIndex; bitMask; bitMask >>= 1 ){\n            tempIndex = index + bitMask;\n            if( tempIndex > this.rowsQuantity ){\n                continue;\n            }\n            if( offset === this.fTree[ tempIndex ] ){\n                return tempIndex;\n            }\n            if( offset > this.fTree[ tempIndex ] ) {\n                index = tempIndex;\n                offset -= this.fTree[ index ];\n            }\n        }\n\n        return index;\n    }\n\n    getOffset( index ){\n        let result = 0;\n        for ( ; index > 0; index -= index & -index ){\n            result += this.fTree[ index ];\n        }\n        return result;\n    }\n\n    /* i starts from 1 here */\n    updateRowHeight( i, delta ){\n        for ( ; i <= this.rowsQuantity; i += i & -i ){\n            this.fTree[ i ] += delta;\n        }\n    }\n\n    updateRowHeights(){\n        const node = this.rowsContainerNode;\n\n        if( node ){\n\n            let index = this.startIndex,\n                diff,\n                cacheChanged = false;\n\n            for( let child of node.children ){\n     \n                diff = child.offsetHeight - this.rowHeights[ index ];\n\n                if( diff ){\n                    cacheChanged = true;\n                    this.rowHeights[ index ] += diff;\n\n                    /*\n                        TODO:\n                            maybe buffer these updates somehow?\n                    */\n                    this.updateRowHeight( index + 1, diff );                  \n                }\n                \n                index++;\n            }\n\n            if( cacheChanged ){\n                this.emit( CACHED_ROWS_HEIGHT );\n            }\n        }\n    }\n\n    updateRowHeightsThrottled = throttle( this.updateRowHeights, 200, this );\n}\n\nexport default VariableSizeList;","const cx = ( baseClass, extraClass ) => extraClass ? `${baseClass} ${extraClass}` : baseClass;\r\n\r\nexport default cx;","const throttle = ( fn, ms, ctx ) => {\n    let timer = 0;\n\n    const cancel = () => {\n        clearTimeout( timer );\n        timer = 0;\n    }\n\n    const invoke = () => {\n        timer = 0;\n        fn.call( ctx );\n    }\n\n    const throttled = () => {\n        if( timer === 0 ){\n            timer = setTimeout( invoke, ms );\n        }\n    }\n\n    throttled.cancel = cancel;\n\n    return throttled;\n}\n\nexport default throttle;"],"sourceRoot":""}