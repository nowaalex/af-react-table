{"version":3,"sources":["webpack://af-virtual-scroll/./src/Context.js","webpack://af-virtual-scroll/./src/components/common/HeightProvider/style.module.scss?9ac1","webpack://af-virtual-scroll/./src/components/common/HeightProvider/index.js","webpack://af-virtual-scroll/./src/components/common/ScrollContainer/style.module.scss?e713","webpack://af-virtual-scroll/./src/components/common/ScrollContainer/index.js","webpack://af-virtual-scroll/./src/constants/events.js","webpack://af-virtual-scroll/./src/hooks/useApi/index.js","webpack://af-virtual-scroll/./src/hooks/useModel/index.js","webpack://af-virtual-scroll/./src/hooks/useForceUpdate/index.js","webpack://af-virtual-scroll/./src/hooks/useSubscription/index.js","webpack://af-virtual-scroll/./src/models/FixedSizeList/index.js","webpack://af-virtual-scroll/./src/models/PubSub/index.js","webpack://af-virtual-scroll/./src/utils/throttle/index.js","webpack://af-virtual-scroll/./src/models/ListBase/index.js","webpack://af-virtual-scroll/./src/models/VariableSizeList/index.js","webpack://af-virtual-scroll/./src/utils/cx/index.js"],"names":["createContext","E","WIDGET_SCROLL_HEIGHT","useSubscription","API","aria-hidden","className","css","style","height","widgetScrollHeight","ScrollContainer","children","props","ref","useRef","useApi","useEffect","el","current","setScrollContainerNode","R","ResizeObserver","entries","length","setWidgetDimensions","Math","round","contentRect","observe","unobserve","tabIndex","cx","onScroll","e","setScrollTop","target","scrollTop","memo","START_INDEX","END_INDEX","ROWS_QUANTITY","EVENTS_ARRAY_LENGTH","useContext","Context","StoreConstructor","dataRef","estimatedRowHeight","overscanRowsCount","rowsQuantity","rowsContainerNode","finalDataRef","Store","startBatch","setViewParams","endBatch","destructor","increment","x","useReducer","callBack","events","prevRenrerRef","forceUpdate","useForceUpdate","on","off","inBatch","queue","FixedSizeList","ListBase","setRowHeight","v","this","rowHeight","remeasure","constructor","super","measureRowsThrottled","getIndex","offset","floor","getOffset","index","measureRows","firstElementChild","offsetHeight","_E","Array","from","_Q","Set","_on","shouldPrepend","fn","prototype","unshift","push","evt","call","prependListener","splice","clear","indexOf","cb","add","emit","ms","ctx","timer","invoke","throttled","setTimeout","cancel","clearTimeout","PubSub","node","scrollContainerNode","updateVisibleRange","widgetHeight","updateEndIndex","endIndex","min","startIndex","max","virtualTopOffset","updateWidgetScrollHeight","throttle","scrollToRow","rowIndex","VariableSizeList","rowHeights","fTree","msb","grow","Error","clz32","curRowHeighsLength","oldRowHeights","Uint32Array","set","fill","j","i","resetCachedHeights","tempIndex","bitMask","result","updateRowHeight","delta","diff","cacheChanged","child","baseClass","extraClass"],"mappings":";uIAEA,SAAeA,E,SAAAA,kB,mHCDf,QAA0B,wBCG1B,MAAMC,EAAI,C,SAAEC,IAUZ,EARuB,KAAMC,QAAiBC,IAC1C,gBACIC,cAAY,OACZC,UAAWC,EACXC,MAAO,CAAEC,OAAQL,EAAIM,uBAE1BT,GCXH,EAA0B,0BCKpBU,EAAmB,IAAsC,IAAtC,UAAEL,EAAF,SAAaM,GAAyB,EAAZC,GAAY,mCAE3D,MAAMC,GAAMC,cACNX,GAAMY,SAsBZ,OApBAC,gBAAU,KACN,MAAMC,EAAKJ,EAAIK,QAEff,EAAIgB,uBAAwBF,GAE5B,MAAMG,EAAI,IAAIC,gBAAgBC,IACH,IAAnBA,EAAQC,QACRpB,EAAIqB,oBAAqBC,KAAKC,MAAOJ,EAAS,GAAIK,YAAYnB,YAMtE,OAFAY,EAAEQ,QAASX,GAEJ,IAAMG,EAAES,UAAWZ,KAC3B,KAOC,iCACQL,EADR,CAEIC,IAAKA,EACLiB,SAAS,IACTzB,WAAW0B,OAAGzB,EAAYD,GAC1BQ,IAAKA,EACLmB,SAAUC,GAAK9B,EAAI+B,aAAcD,EAAEE,OAAOC,WAN9C,WAQI,SAAC,EAAD,IACCzB,OAKb,GAAe0B,UAAM3B,I,mFC9Cd,MAAM4B,EAA6B,EAC7BC,EAA6B,EAC7BC,EAA6B,EAC7BvC,EAA6B,EAE7BwC,EAA6B,G,uECF1C,MAEA,EAFe,KAAMC,gBAAYC,M,6DCGjC,MAyBA,EAzBiB,CAAEC,EAAkBC,EAASC,EAAoBC,EAAmBC,EAAcC,KAE/F,MAAMC,GAAepC,cAErB,IAAIqC,EAAQD,EAAahC,QAkBzB,OAhBOiC,aAAiBP,IACpBO,EAAQD,EAAahC,QAAU,IAAI0B,GAGnCC,IACAA,EAAQ3B,QAAUiC,GAGtBA,EAAMC,aAAaC,cAAeP,EAAoBC,EAAmBC,EAAcC,IAEvFjC,gBAAU,KACNmC,EAAMG,eAGVtC,gBAAU,IAAM,IAAMmC,EAAMI,cAAc,CAAEJ,IAErCA,I,6DC1BX,MAAMK,EAAYC,GAAKA,EAAI,EAI3B,EAFuB,KAAMC,gBAAYF,EAAW,GAAK,G,cCAzD,MAyBA,EAzBwB,CAAEG,EAAUC,KAEhC,MAAMC,GAAgB/C,YAAQ,MACxBX,GAAMY,SACN+C,EAAcC,IAkBpB,OAhBA/C,gBAAU,KACNb,EAAI6D,GAAIF,KAAgBF,GACjB,IAAMzD,EAAI8D,IAAKH,KAAgBF,KACvCA,GAECzD,EAAI+D,QAKJ/D,EAAIgE,MAAOL,GAGXD,EAAc3C,QAAUyC,EAAUxD,GAG/B0D,EAAc3C,U,wEChBzB,MAAMkD,UAAsBC,IAIxBC,aAAcC,GACNA,IAAMC,KAAKC,YACXD,KAAKC,UAAYF,EACjBC,KAAKE,aAIbC,cACIC,QADS,KATbH,UAAY,EAYRD,KAAKR,GAAIQ,KAAKK,qBAAsBrC,MAIxCsC,SAAUC,GACN,OAAOP,KAAKC,WAAahD,KAAKuD,MAAOD,EAASP,KAAKC,WAGvDQ,UAAWC,GACP,OAAOA,EAAQV,KAAKC,UAGxBU,cACqD,MAA7CX,KAAKvB,mBAAqBuB,KAAKxB,cAC/BwB,KAAKF,cAAc,SAAAE,KAAKvB,kBAAkBmC,wBAAvB,IAA0CC,eAAgB,IAKzF,W,6DCyCA,QAlFA,MAAa,mBAGTC,GAAKC,MAAMC,KAAK,CAAEjE,OAAQkB,OAAuB,IAAM,KAH9C,KAMTgD,GAAK,IAAIC,IANA,KASTxB,QAAU,EAEVyB,IAAKhC,EAAUC,EAAQgC,GACnB,MAAMC,EAAKD,EAAgBL,MAAMO,UAAUC,QAAUR,MAAMO,UAAUE,KACrE,IAAK,IAAIC,KAAOrC,EACZiC,EAAGK,KAAM1B,KAAKc,GAAIW,GAAOtC,GAE7B,OAAOa,KAGXR,GAAIL,KAAaC,GACb,OAAOY,KAAKmB,IAAKhC,EAAUC,GAAQ,GAGvCuC,gBAAiBxC,KAAaC,GAC1B,OAAOY,KAAKmB,IAAKhC,EAAUC,GAAQ,GAGvCL,aACI,IAAK,IAAIK,KAAUY,KAAKc,GACpB1B,EAAOwC,OAAQ,GAEnB5B,KAAKiB,GAAGY,QAGZpC,IAAKN,KAAaC,GACd,IAAK,IAAIqC,KAAOrC,EACZY,KAAKc,GAAIW,GAAMG,OAAQ5B,KAAKc,GAAIW,GAAMK,QAAS3C,KAAe,EAAG,GAErE,OAAOa,KAGXL,MAAOoC,GAMH/B,KAAKiB,GAAGe,IAAKD,GAGjBE,KAAMR,GACF,GAAIzB,KAAKN,QACL,IAAK,IAAIqC,KAAM/B,KAAKc,GAAIW,GACpBzB,KAAKiB,GAAGe,IAAKD,QAIjB,IAAK,IAAIA,KAAM/B,KAAKc,GAAIW,GACpBM,EAAGL,KAAM1B,MAGjB,OAAOA,KAKXpB,aAEI,OADAoB,KAAKN,UACEM,KAGXlB,WACI,MAAOkB,KAAKN,QAAS,CACjB,IAAK,IAAIqC,KAAM/B,KAAKiB,GAChBc,EAAGL,KAAM1B,MAEbA,KAAKiB,GAAGY,QAEZ,OAAO7B,OCxDf,EAxBiB,CAAEqB,EAAIa,EAAIC,KACvB,IAAIC,EAAQ,EAEZ,MAKMC,EAAS,KACXD,EAAQ,EACRf,EAAGK,KAAMS,IAGPG,EAAY,KACA,IAAVF,IACAA,EAAQG,WAAYF,EAAQH,KAMpC,OAFAI,EAAUE,OAhBK,KACXC,aAAcL,GACdA,EAAQ,GAgBLE,GCmHX,QA9HA,cAAuBI,EAYnB/F,uBAAwBgG,GACpB3C,KAAK4C,oBAAsBD,EAG/BjF,aAAcqC,GACNA,IAAMC,KAAKpC,YACXoC,KAAKpC,UAAYmC,EACjBC,KAAK6C,sBAIb7F,oBAAqBhB,GACbA,IAAWgE,KAAK8C,eAChB9C,KAAK8C,aAAe9G,EACpBgE,KAAK+C,kBAGT/C,KAAKK,uBAGT0C,iBACI,MAAMC,EAAW/F,KAAKgG,IAAKjD,KAAKxB,aAAcwB,KAAKM,SAAUN,KAAKpC,UAAYoC,KAAK8C,cAAiB9C,KAAKzB,mBAOzG,OALIyE,IAAahD,KAAKgD,WAClBhD,KAAKgD,SAAWA,EAChBhD,KAAKiC,KAAMlE,OAGRiC,KAGX6C,qBAEI,MAAMK,EAAajG,KAAKkG,IAAK,EAAGlG,KAAKgG,IAAKjD,KAAKxB,aAAcwB,KAAKM,SAAUN,KAAKpC,YAAgBoC,KAAKzB,mBAQtG,OANI2E,IAAelD,KAAKkD,aACpBlD,KAAKkD,WAAaA,EAClBlD,KAAKoD,iBAAmBpD,KAAKS,UAAWyC,GACxClD,KAAKiC,KAAMnE,OAGRkC,KAAK+C,iBAKhB7C,YACI,OAAOF,KACFqD,2BACAR,qBAGT1C,cACIC,QADS,KA7DbxC,UAAY,EA6DC,KA5DbY,aAAe,EA4DF,KA1DbD,kBAAoB,EA0DP,KAzDbuE,aAAe,EAyDF,KAxDbxE,mBAAqB,EAwDR,KAvDbG,kBAAoB,KAuDP,KAtDbmE,oBAAsB,KAsDT,KAqDbvC,qBAAuBiD,EAAUtD,KAAKW,YAAa,IAAKX,MArD3C,KAwDbkD,WAAa,EAxDA,KAyDbF,SAAW,EAzDE,KA0DbI,iBAAmB,EA1DN,KA2DbnH,mBAAqB,EAxDjB+D,KACKR,GAAIQ,KAAKqD,yBAA0BrF,MACnCwB,GAAIQ,KAAK+C,eAAgB/E,MAGlCe,aACIiB,KAAKK,qBAAqBmC,SAC1BpC,MAAMrB,aAGVwE,YAAaC,GACLxD,KAAK4C,sBACL5C,KAAK4C,oBAAoBhF,UAAYoC,KAAKS,UAAW+C,IAO7DH,2BACI,MAAMtD,EAAIC,KAAKS,UAAWT,KAAKxB,cAK/B,OAJIuB,IAAMC,KAAK/D,qBACX+D,KAAK/D,mBAAqB8D,EAC1BC,KAAKiC,KAAMxG,OAERuE,KAKXnB,cAAeP,EAAoBC,EAAmBC,EAAcC,GAEhEuB,KAAK1B,mBAAqBA,EAC1B0B,KAAKvB,kBAAoBA,EAEzBuB,KAAKpB,aAEDL,IAAsByB,KAAKzB,oBAC3ByB,KAAKzB,kBAAoBA,EACzByB,KAAKL,MAAOK,KAAK6C,qBAGjBrE,IAAiBwB,KAAKxB,eACtBwB,KAAKxB,aAAeA,EACpBwB,KAAKiC,KAAMjE,OAGfgC,KAAKlB,c,wEC9Gb,MAAM2E,UAAyB5D,IAW3BM,cACIC,QADS,KATbsD,WAAa,GASA,KARbC,MAAQ,GAQK,KAFbC,IAAM,EAKF5D,KAEK2B,gBAAiB3B,KAAK6D,KAAM7F,MAC5BwB,GAAIQ,KAAKK,qBAAsBvC,KAAaC,MAGrD8F,OACI,MAAM,aAAErF,GAAiBwB,KAEzB,GAAIxB,EAAe,GAAKA,EAAe,WACnC,MAAM,IAAIsF,MAAJ,uBAAkCtF,EAAlC,gCAGVwB,KAAK4D,IAAMpF,GAAgB,GAAK,GAAKvB,KAAK8G,MAAOvF,GAEjD,MAAMwF,EAAqBhE,KAAK0D,WAAW3G,OAE3C,GAAIyB,EAAewF,EAAoB,CAEnC,MAAMC,EAAgBjE,KAAK0D,WAK3B,GAHA1D,KAAK0D,WAAa,IAAIQ,YAAa1F,GACnCwB,KAAK2D,MAAQ,IAAIO,YAAa1F,EAAe,GAEzCwF,EAAoB,CACpBhE,KAAK0D,WAAWS,IAAKF,GACrBjE,KAAK0D,WAAWU,KAAMpE,KAAK1B,mBAAoB0F,GAQ/ChE,KAAK2D,MAAMQ,IAAKnE,KAAK0D,WAAY,GAEjC,IAAK,IAAWW,EAAPC,EAAI,EAAMA,GAAK9F,EAAc8F,IAClCD,EAAIC,GAAMA,GAAKA,GACXD,GAAK7F,IACLwB,KAAK2D,MAAOU,IAAOrE,KAAK2D,MAAOW,IAIvCtE,KAAKE,iBAGLF,KAAKuE,sBAKjBA,mBAAoBtE,EAAYD,KAAK1B,oBAEjC0B,KAAK1B,mBAAqB2B,EAC1BD,KAAK0D,WAAWU,KAAMnE,GAGtB,IAAM,IAAIqE,EAAI,EAAGA,GAAKtE,KAAKxB,aAAc8F,IACrCtE,KAAK2D,MAAOW,GAAMrE,GAAcqE,GAAKA,GAGzCtE,KAAKE,YAGTI,SAAUC,GACN,IAAIG,EAAQ,EAEZ,IAAK,IAAwB8D,EAApBC,EAAUzE,KAAK4D,IAAgBa,EAASA,IAAY,EAEzD,GADAD,EAAY9D,EAAQ+D,IAChBD,EAAYxE,KAAKxB,cAArB,CAGA,GAAI+B,IAAWP,KAAK2D,MAAOa,GACvB,OAAOA,EAEPjE,EAASP,KAAK2D,MAAOa,KACrB9D,EAAQ8D,EACRjE,GAAUP,KAAK2D,MAAOjD,IAI9B,OAAOA,EAGXD,UAAWC,GAOP,IAAIgE,EAAS,EAEb,KAAQhE,EAAQ,EAAGA,GAASA,GAASA,EACjCgE,GAAU1E,KAAK2D,MAAOjD,GAG1B,OAAOgE,EAIXC,gBAAiBL,EAAGM,GAChB,KAAQN,GAAKtE,KAAKxB,aAAc8F,GAAKA,GAAKA,EACtCtE,KAAK2D,MAAOW,IAAOM,EAI3BjE,cACI,MAAMgC,EAAO3C,KAAKvB,kBAElB,GAAIkE,EAAM,CAEN,IACIkC,EADAnE,EAAQV,KAAKkD,WAEb4B,GAAe,EAEnB,IAAK,IAAIC,KAASpC,EAAKxG,SAEnB0I,EAAOE,EAAMlE,aAAeb,KAAK0D,WAAYhD,GAEzCmE,IACAC,GAAe,EACf9E,KAAK0D,WAAYhD,IAAWmE,EAM5B7E,KAAK2E,gBAAiBjE,EAAQ,EAAGmE,IAGrCnE,IAGAoE,GACA9E,KAAKE,cAMrB,W,8CCzKA,MAEA,EAFW,CAAE8E,EAAWC,IAAgBA,EAAgBD,EAAN,IAAmBC,EAAeD","file":"7fd50d53e5c1632ba9a4.js","sourcesContent":["import { createContext } from \"react\";\r\n\r\nexport default createContext();","// extracted by mini-css-extract-plugin\nexport default {\"wrapper\":\"a2uMg3Zj4kpPT6J8EoqLx\"};","import useSubscription from \"hooks/useSubscription\";\nimport css from \"./style.module.scss\";\nimport { WIDGET_SCROLL_HEIGHT } from \"constants/events\";\n\nconst E = [ WIDGET_SCROLL_HEIGHT ];\n\nconst HeightProvider = () => useSubscription( API => (\n    <div\n        aria-hidden=\"true\"\n        className={css.wrapper}\n        style={{ height: API.widgetScrollHeight }}\n    />\n), E );\n\nexport default HeightProvider","// extracted by mini-css-extract-plugin\nexport default {\"wrapper\":\"_3Jl24WrVf4wfsfDMBe4LVm\"};","import { useRef, memo, useEffect } from \"react\";\r\nimport cx from \"utils/cx\";\r\nimport useApi from \"hooks/useApi\";\r\nimport HeightProvider from \"../HeightProvider\";\r\nimport css from \"./style.module.scss\";\r\n\r\nconst ScrollContainer = ({ className, children, ...props }) => {\r\n\r\n    const ref = useRef();\r\n    const API = useApi();\r\n\r\n    useEffect(() => {\r\n        const el = ref.current;\r\n\r\n        API.setScrollContainerNode( el );\r\n\r\n        const R = new ResizeObserver( entries => {\r\n            if( entries.length === 1 ){\r\n                API.setWidgetDimensions( Math.round( entries[ 0 ].contentRect.height ) );\r\n            }\r\n        });\r\n\r\n        R.observe( el );\r\n\r\n        return () => R.unobserve( el );\r\n    }, []);\r\n    \r\n    /*\r\n        tabIndex=\"0\" is for proper keyboard nav\r\n        https://bugzilla.mozilla.org/show_bug.cgi?id=1346159\r\n    */\r\n    return (\r\n        <div\r\n            {...props}\r\n            ref={ref}\r\n            tabIndex=\"0\"\r\n            className={cx(css.wrapper,className)}\r\n            ref={ref}\r\n            onScroll={e => API.setScrollTop( e.target.scrollTop )}\r\n        >\r\n            <HeightProvider />\r\n            {children}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default memo( ScrollContainer );","export const START_INDEX                = 0;\nexport const END_INDEX                  = 1;\nexport const ROWS_QUANTITY              = 2;\nexport const WIDGET_SCROLL_HEIGHT       = 3;\n\nexport const EVENTS_ARRAY_LENGTH        = 4;","import { useContext } from \"react\";\nimport Context from \"../../Context\";\n\nconst useApi = () => useContext( Context );\n\nexport default useApi;","import { useRef, useEffect } from \"react\";\n\n/*\n    dataRef is to call Data methods from outside( Data.scrollTo(), etc. ).\n    As it is not dom-related, I decided to avoid forwardRef\n*/\nconst useStore = ( StoreConstructor, dataRef, estimatedRowHeight, overscanRowsCount, rowsQuantity, rowsContainerNode ) => {\n\n    const finalDataRef = useRef();\n\n    let Store = finalDataRef.current;\n\n    if( !( Store instanceof StoreConstructor ) ){\n        Store = finalDataRef.current = new StoreConstructor();\n    }\n\n    if( dataRef ){\n        dataRef.current = Store;\n    }\n\n    Store.startBatch().setViewParams( estimatedRowHeight, overscanRowsCount, rowsQuantity, rowsContainerNode );\n\n    useEffect(() => {\n        Store.endBatch();\n    });\n    \n    useEffect(() => () => Store.destructor(), [ Store ]);\n\n    return Store;\n};\n\nexport default useStore;","import { useReducer } from \"react\";\n\nconst increment = x => x + 1;\n\nconst useForceUpdate = () => useReducer( increment, 0 )[ 1 ];\n\nexport default useForceUpdate;","import { useRef, useEffect } from \"react\";\nimport useForceUpdate from \"../useForceUpdate\";\nimport useApi from \"../useApi\";\n\nconst useSubscription = ( callBack, events ) => {\n    \n    const prevRenrerRef = useRef( null );\n    const API = useApi();\n    const forceUpdate = useForceUpdate();\n    \n    useEffect(() => {\n        API.on( forceUpdate, ...events );\n        return () => API.off( forceUpdate, ...events );\n    }, events );\n\n    if( API.inBatch ){\n        /*\n            Somebody tried to rerender, while we were in batch.\n            On batch finish component definitely must be rerendered.\n        */\n        API.queue( forceUpdate );\n    }\n    else{\n        prevRenrerRef.current = callBack( API );\n    }\n    \n    return prevRenrerRef.current;\n}\n\nexport default useSubscription;","import ListBase from \"../ListBase\";\nimport throttle from \"utils/throttle\";\n\nimport {\n    START_INDEX,\n    END_INDEX,\n    ROWS_QUANTITY,\n    WIDGET_SCROLL_HEIGHT,\n} from \"constants/events\";\n\nclass FixedSizeList extends ListBase {\n\n    rowHeight = 0;\n\n    setRowHeight( v ){\n        if( v !== this.rowHeight ){\n            this.rowHeight = v;\n            this.remeasure();\n        }\n    }\n\n    constructor(){\n        super();\n\n        this.on( this.measureRowsThrottled, ROWS_QUANTITY );\n    }\n\n\n    getIndex( offset ){\n        return this.rowHeight && Math.floor( offset / this.rowHeight );\n    }\n\n    getOffset( index ){\n        return index * this.rowHeight;\n    }\n\n    measureRows(){\n        if( this.rowsContainerNode && this.rowsQuantity ){\n            this.setRowHeight( this.rowsContainerNode.firstElementChild?.offsetHeight || 0 );\n        }\n    }    \n}\n\nexport default FixedSizeList;","import { EVENTS_ARRAY_LENGTH } from \"constants/events\";\n\nclass PubSub {\n\n    /* All callbacks are known in advance, so we can allocate in construcror */\n    _E = Array.from({ length: EVENTS_ARRAY_LENGTH }, () => []);\n\n    /* query of callbacks, that should run after batch end */\n    _Q = new Set();\n\n    /* depth of batch */\n    inBatch = 0;\n\n    _on( callBack, events, shouldPrepend ){\n        const fn = shouldPrepend ? Array.prototype.unshift : Array.prototype.push;\n        for( let evt of events ){\n            fn.call( this._E[ evt ], callBack );\n        }\n        return this;\n    }\n\n    on( callBack, ...events ){\n        return this._on( callBack, events, false );\n    }\n\n    prependListener( callBack, ...events ){\n        return this._on( callBack, events, true );\n    }\n\n    destructor(){\n        for( let events of this._E ){\n            events.splice( 0 );\n        }\n        this._Q.clear();\n    }\n\n    off( callBack, ...events ){\n        for( let evt of events ){\n            this._E[ evt ].splice( this._E[ evt ].indexOf( callBack ) >>> 0, 1 );\n        }\n        return this;\n    }\n\n    queue( cb ){\n        if( process.env.NODE_ENV !== \"production\" ){\n            if( !this.inBatch ){\n                console.error( \"trying to add event to batch queue, while inBatch is 0\" );\n            }\n        }\n        this._Q.add( cb );\n    }\n\n    emit( evt ){\n        if( this.inBatch ){\n            for( let cb of this._E[ evt ] ){\n                this._Q.add( cb );\n            }\n        }\n        else{\n            for( let cb of this._E[ evt ] ){\n                cb.call( this );\n            }\n        }\n        return this;\n    }\n\n    /* inspired by mobx */\n\n    startBatch(){\n        this.inBatch++;\n        return this;\n    }\n\n    endBatch(){\n        if( !--this.inBatch ){\n            for( let cb of this._Q ){\n                cb.call( this );\n            }\n            this._Q.clear();\n        }\n        return this;\n    }\n}\n\nexport default PubSub;","const throttle = ( fn, ms, ctx ) => {\n    let timer = 0;\n\n    const cancel = () => {\n        clearTimeout( timer );\n        timer = 0;\n    }\n\n    const invoke = () => {\n        timer = 0;\n        fn.call( ctx );\n    }\n\n    const throttled = () => {\n        if( timer === 0 ){\n            timer = setTimeout( invoke, ms );\n        }\n    }\n\n    throttled.cancel = cancel;\n\n    return throttled;\n}\n\nexport default throttle;","import PubSub from \"../PubSub\";\nimport throttle from \"utils/throttle\";\n\nimport {\n    START_INDEX,\n    END_INDEX,\n    ROWS_QUANTITY,\n    WIDGET_SCROLL_HEIGHT,\n} from \"constants/events\";\n\nclass ListBase extends PubSub {\n\n    /* Provided from renderer */\n    scrollTop = 0;\n    rowsQuantity = 0;\n    /* must not be >= 1 */\n    overscanRowsCount = 2;\n    widgetHeight = 0;\n    estimatedRowHeight = 0;\n    rowsContainerNode = null;\n    scrollContainerNode = null;\n\n    setScrollContainerNode( node ){\n        this.scrollContainerNode = node;\n    }\n\n    setScrollTop( v ){\n        if( v !== this.scrollTop ){\n            this.scrollTop = v;\n            this.updateVisibleRange();\n        }\n    }\n\n    setWidgetDimensions( height ){\n        if( height !== this.widgetHeight ){\n            this.widgetHeight = height;\n            this.updateEndIndex();\n        }\n\n        this.measureRowsThrottled();\n    }\n\n    updateEndIndex(){\n        const endIndex = Math.min( this.rowsQuantity, this.getIndex( this.scrollTop + this.widgetHeight ) + this.overscanRowsCount );\n\n        if( endIndex !== this.endIndex ){\n            this.endIndex = endIndex;\n            this.emit( END_INDEX );\n        }\n\n        return this;\n    }\n\n    updateVisibleRange(){\n\n        const startIndex = Math.max( 0, Math.min( this.rowsQuantity, this.getIndex( this.scrollTop ) ) - this.overscanRowsCount );\n\n        if( startIndex !== this.startIndex ){\n            this.startIndex = startIndex;\n            this.virtualTopOffset = this.getOffset( startIndex );\n            this.emit( START_INDEX );\n        }\n\n        return this.updateEndIndex();\n    }\n\n\n    /* must be called when row height/heights change */\n    remeasure(){\n        return this\n            .updateWidgetScrollHeight()\n            .updateVisibleRange();\n    }\n\n    constructor(){\n        super()\n\n        this\n            .on( this.updateWidgetScrollHeight, ROWS_QUANTITY )\n            .on( this.updateEndIndex, ROWS_QUANTITY );\n    }\n\n    destructor(){\n        this.measureRowsThrottled.cancel();\n        super.destructor();\n    }\n\n    scrollToRow( rowIndex ){\n        if( this.scrollContainerNode ){\n            this.scrollContainerNode.scrollTop = this.getOffset( rowIndex );\n        }\n        else if( process.env.NODE_ENV !== \"production\" ){\n            console.error( \"scrollContainerNode is not set\" );\n        }\n    }\n\n    updateWidgetScrollHeight(){\n        const v = this.getOffset( this.rowsQuantity );\n        if( v !== this.widgetScrollHeight ){\n            this.widgetScrollHeight = v;\n            this.emit( WIDGET_SCROLL_HEIGHT );\n        }\n        return this;\n    }\n\n    \n\n    setViewParams( estimatedRowHeight, overscanRowsCount, rowsQuantity, rowsContainerNode ){\n\n        this.estimatedRowHeight = estimatedRowHeight;\n        this.rowsContainerNode = rowsContainerNode;\n\n        this.startBatch();\n\n        if( overscanRowsCount !== this.overscanRowsCount ){\n            this.overscanRowsCount = overscanRowsCount;\n            this.queue( this.updateVisibleRange );\n        }\n\n        if( rowsQuantity !== this.rowsQuantity ){\n            this.rowsQuantity = rowsQuantity;\n            this.emit( ROWS_QUANTITY );\n        }\n\n        this.endBatch();\n    }\n\n    measureRowsThrottled = throttle( this.measureRows, 200, this );\n\n    /* Calculated inside model */\n    startIndex = 0;\n    endIndex = 0;\n    virtualTopOffset = 0;\n    widgetScrollHeight = 0;\n}\n\nexport default ListBase;","import ListBase from \"../ListBase\";\n\nimport {\n    ROWS_QUANTITY,\n    START_INDEX,\n    END_INDEX,\n} from \"constants/events\";\n\n/*\n    TODO:\n        when estimatedRowHeight is not correct, scroll behavior is weird here\n        perform resetCacheHeights from useEffect on rowRenderer change\n*/\n\nclass VariableSizeList extends ListBase {\n    \n    rowHeights = [];\n    fTree = [];\n\n    /*\n        most significant bit of this.rowsQuantity;\n        caching it to avoid Math.clz32 calculations on every getIndex call\n    */\n    msb = 0;\n    \n    constructor(){\n        super();\n\n        this\n            /* must be done before events, attached in ListBase */\n            .prependListener( this.grow, ROWS_QUANTITY )\n            .on( this.measureRowsThrottled, START_INDEX, END_INDEX );            \n    }\n\n    grow(){\n        const { rowsQuantity } = this;\n\n        if( rowsQuantity < 0 || rowsQuantity > 0x7fffffff ){\n            throw new Error( `Wrong rowsQuantity: ${rowsQuantity}. Must be 0...2_147_483_647.` )\n        }\n\n        this.msb = rowsQuantity && 1 << 31 - Math.clz32( rowsQuantity );\n\n        const curRowHeighsLength = this.rowHeights.length;\n\n        if( rowsQuantity > curRowHeighsLength ){\n\n            const oldRowHeights = this.rowHeights;\n            \n            this.rowHeights = new Uint32Array( rowsQuantity );\n            this.fTree = new Uint32Array( rowsQuantity + 1 );\n\n            if( curRowHeighsLength ){\n                this.rowHeights.set( oldRowHeights );\n                this.rowHeights.fill( this.estimatedRowHeight, curRowHeighsLength );\n\n\n                /* \n                    Creating fenwick tree from an array in linear time;\n                    It is much more efficient, than calling updateRowHeight N times.\n                */\n\n                this.fTree.set( this.rowHeights, 1 );\n\n                for( let i = 1, j; i <= rowsQuantity; i++ ){\n                    j = i + ( i & -i );\n                    if( j <= rowsQuantity ){\n                        this.fTree[ j ] += this.fTree[ i ];\n                    }\n                }\n\n                this.remeasure();\n            }\n            else {\n                this.resetCachedHeights();\n            }\n        }        \n    }\n\n    resetCachedHeights( rowHeight = this.estimatedRowHeight ){\n\n        this.estimatedRowHeight = rowHeight;\n        this.rowHeights.fill( rowHeight );\n\n        /* Filling FenwickTee with single value  */\n        for ( let i = 1; i <= this.rowsQuantity; i++ ){\n            this.fTree[ i ] = rowHeight * ( i & -i );\n        }\n\n        this.remeasure();\n    }\n\n    getIndex( offset ){\n        let index = 0;\n        \n        for( let bitMask = this.msb, tempIndex; bitMask; bitMask >>= 1 ){\n            tempIndex = index + bitMask;\n            if( tempIndex > this.rowsQuantity ){\n                continue;\n            }\n            if( offset === this.fTree[ tempIndex ] ){\n                return tempIndex;\n            }\n            if( offset > this.fTree[ tempIndex ] ) {\n                index = tempIndex;\n                offset -= this.fTree[ index ];\n            }\n        }\n\n        return index;\n    }\n\n    getOffset( index ){\n        if( process.env.NODE_ENV !== \"production\" ){\n            if( index > this.rowsQuantity ){\n                throw new Error( \"index must not be > rowsQuantity\" );\n            }\n        }\n\n        let result = 0;\n\n        for ( ; index > 0; index -= index & -index ){\n            result += this.fTree[ index ];\n        }\n\n        return result;\n    }\n\n    /* i starts from 1 here */\n    updateRowHeight( i, delta ){\n        for ( ; i <= this.rowsQuantity; i += i & -i ){\n            this.fTree[ i ] += delta;\n        }\n    }\n\n    measureRows(){\n        const node = this.rowsContainerNode;\n\n        if( node ){\n\n            let index = this.startIndex,\n                diff,\n                cacheChanged = false;\n\n            for( let child of node.children ){\n     \n                diff = child.offsetHeight - this.rowHeights[ index ];\n\n                if( diff ){\n                    cacheChanged = true;\n                    this.rowHeights[ index ] += diff;\n\n                    /*\n                        TODO:\n                            maybe buffer these updates somehow?\n                    */\n                    this.updateRowHeight( index + 1, diff );                  \n                }\n                \n                index++;\n            }\n\n            if( cacheChanged ){\n                this.remeasure();\n            }\n        }\n    }\n}\n\nexport default VariableSizeList;","const cx = ( baseClass, extraClass ) => extraClass ? `${baseClass} ${extraClass}` : baseClass;\r\n\r\nexport default cx;"],"sourceRoot":""}