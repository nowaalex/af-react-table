{"version":3,"sources":["webpack://af-virtual-scroll/./src/components/common/ExtraHeight/index.js","webpack://af-virtual-scroll/./src/components/Table/Scroller/style.module.scss?b61c","webpack://af-virtual-scroll/./src/components/Table/Scroller/index.js","webpack://af-virtual-scroll/./src/components/Table/Rows/index.js","webpack://af-virtual-scroll/./src/components/Table/Colgroup/index.js","webpack://af-virtual-scroll/./src/components/Table/style.module.scss?eda3","webpack://af-virtual-scroll/./src/components/Table/index.js","webpack://af-virtual-scroll/./src/components/Table/renderers.js"],"names":["children","API","useApi","el","ref","useState","useEffect","prevHeight","observe","height","updateExtraStickyHeight","unobserve","cloneElement","E","START_INDEX","useSubscription","className","css","aria-hidden","style","virtualTopOffset","END_INDEX","Rows","columns","renderRow","Row","getRowData","getRowProps","Cell","startIndex","endIndex","result","i","push","index","memo","Colgroup","map","dataKey","background","border","width","Table","fixed","estimatedRowHeight","renderHeaderCells","renderTfootContent","rowsQuantity","overscanRowsCount","headless","dataRef","props","rowsContainerNode","rowsContainerRef","Store","useModel","FixedHeightsStore","VariableHeightsStore","Context","value","ScrollContainer","cx","ExtraHeight","defaultProps","Object","assign","commonDefaultProps","RowProps","rowData","column","colSpan","length","minWidth","label","render","format","cellData","undefined"],"mappings":"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","file":"5256327a06e7eed43132.js","sourcesContent":["import { useState, cloneElement, useEffect } from \"react\";\nimport { observe, unobserve } from \"utils/heightObserver\";\nimport useApi from \"hooks/useApi\";\n\nconst ExtraStickyHeight = ({ children }) => {\n\n    const API = useApi();\n    const [ el, ref ] = useState();\n\n    useEffect(() => {\n        if( el ){\n            let prevHeight = 0;\n\n            observe( el, height => {\n                API.updateExtraStickyHeight( height - prevHeight );\n                prevHeight = height;\n            });\n    \n            return () => {\n                unobserve( el );\n                API.updateExtraStickyHeight( -prevHeight );\n            }\n        }\n    }, [ el ]);\n\n    return cloneElement( children, { ref });\n}\n\nexport default ExtraStickyHeight;","// extracted by mini-css-extract-plugin\nexport default {\"wrapper\":\"_24qdqpq2QWr-ymEb1PSDPY\"};","import css from \"./style.module.scss\";\r\nimport useSubscription from \"hooks/useSubscription\";\r\nimport { START_INDEX } from \"constants/events\";\r\n\r\nconst E = [ START_INDEX ];\r\n\r\n/*\r\n    Hmm, I can't put here more than ~ 3 000 000. Maybe need to put one more row in case this height is > 3 000 000\r\n*/\r\nconst Scroller = () => useSubscription( API => (\r\n    <tbody\r\n        className={css.wrapper}\r\n        aria-hidden=\"true\"\r\n        style={{ height: API.virtualTopOffset }}\r\n    />\r\n), E );\r\n\r\nexport default Scroller;","import { memo } from \"react\";\r\nimport useSubscription from \"hooks/useSubscription\";\r\nimport { START_INDEX, END_INDEX } from \"constants/events\";\r\n\r\nconst E = [ START_INDEX, END_INDEX ];\r\n\r\n/* can't use transform translate because of fucking borders */\r\nconst Rows = ({ columns, renderRow, Row, getRowData, getRowProps, Cell }) => useSubscription( API => {\r\n\r\n    const { startIndex, endIndex } = API;\r\n\r\n    const result = [];\r\n\r\n    for( let i = startIndex; i < endIndex; i++ ){\r\n        result.push(renderRow({\r\n            index: i,\r\n            columns,\r\n            getRowData,\r\n            getRowProps,\r\n            Cell,\r\n            Row\r\n        }));\r\n    }\r\n\r\n    return result;\r\n}, E );\r\n\r\nexport default memo( Rows );","import { memo } from \"react\";\r\n\r\nconst Colgroup = ({ columns }) => (\r\n    <colgroup>\r\n        {columns.map(({ dataKey, background, border, width }) => (\r\n            <col\r\n                key={dataKey}\r\n                style={{\r\n                    width,\r\n                    background,\r\n                    border\r\n                }}\r\n            />\r\n        ))}\r\n    </colgroup>\r\n);\r\n\r\nexport default memo( Colgroup );","// extracted by mini-css-extract-plugin\nexport default {\"wrapper\":\"_3xHZ6hLxyHZ-v8LLU1YA7y\",\"bodyTable\":\"_3VNLkND9VRhxpdmzEGLiXt\"};","import { memo, useState } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\n\r\nimport commonDefaultProps from \"../common/defaultProps\";\r\n\r\nimport cx from \"utils/cx\";\r\n\r\nimport Context from \"Context\";\r\nimport useModel from \"hooks/useModel\";\r\n\r\nimport VariableHeightsStore from \"models/VariableSizeList\";\r\nimport FixedHeightsStore from \"models/FixedSizeList\";\r\n\r\nimport ScrollContainer from \"../common/ScrollContainer\";\r\nimport ExtraHeight from \"../common/ExtraHeight\";\r\n\r\nimport Scroller from \"./Scroller\";\r\nimport Rows from \"./Rows\";\r\nimport Colgroup from \"./Colgroup\";\r\n\r\nimport {\r\n    renderRow,\r\n    Row,\r\n    renderHeaderCells,\r\n    Cell\r\n} from \"./renderers\";\r\n\r\nimport css from \"./style.module.scss\";\r\n\r\n/*\r\n    Todo:\r\n        * think about border-collapse offsetHeight issue ( maybe throw border-collapse )\r\n*/\r\n\r\nconst Table = ({\r\n    fixed,\r\n    estimatedRowHeight,\r\n    columns,\r\n    getRowData,\r\n    getRowProps,\r\n    renderRow,\r\n    Row,\r\n    renderHeaderCells,\r\n    renderTfootContent,\r\n    Cell,\r\n    rowsQuantity,\r\n    overscanRowsCount,\r\n    headless,\r\n    dataRef,\r\n    className,\r\n    ...props\r\n}) => {\r\n\r\n    const [ rowsContainerNode, rowsContainerRef ] = useState();\r\n\r\n    const Store = useModel(\r\n        fixed ? FixedHeightsStore : VariableHeightsStore,\r\n        dataRef,\r\n        estimatedRowHeight,\r\n        overscanRowsCount,\r\n        rowsQuantity,\r\n        rowsContainerNode\r\n    );\r\n        \r\n    return (\r\n        <Context.Provider value={Store}>\r\n            <ScrollContainer className={cx(css.wrapper,className)} {...props}>\r\n                <table className={css.bodyTable}>\r\n                    <Colgroup columns={columns} />\r\n                    {headless ? null : (\r\n                        <ExtraHeight>\r\n                            <thead>\r\n                                <tr>\r\n                                    {renderHeaderCells(columns)}\r\n                                </tr>\r\n                            </thead>\r\n                        </ExtraHeight>\r\n                    )}\r\n                    <Scroller />\r\n                    <tbody ref={rowsContainerRef}>\r\n                        <Rows\r\n                            columns={columns}\r\n                            getRowData={getRowData}\r\n                            getRowProps={getRowProps}\r\n                            Row={Row}\r\n                            renderRow={renderRow}\r\n                            Cell={Cell}\r\n                        />\r\n                    </tbody>\r\n                    {renderTfootContent ? (\r\n                        <ExtraHeight>\r\n                            <tfoot>\r\n                                {renderTfootContent( columns )}\r\n                            </tfoot>\r\n                        </ExtraHeight>\r\n                    ) : null}\r\n                </table>\r\n            </ScrollContainer>\r\n        </Context.Provider>\r\n    );\r\n}\r\n\r\nTable.propTypes = {\r\n    rowsQuantity: PropTypes.number.isRequired,\r\n    className: PropTypes.string,\r\n    fixed: PropTypes.bool,\r\n    overscanRowsCount: PropTypes.number,\r\n    estimatedRowHeight: PropTypes.number,\r\n    columns: PropTypes.arrayOf(\r\n        PropTypes.oneOfType([\r\n            PropTypes.string,\r\n                PropTypes.shape({\r\n                // unique key for column\r\n                dataKey: PropTypes.string.isRequired,\r\n\r\n                // for details see CellComponent implementation\r\n                format: PropTypes.func,\r\n                render: PropTypes.func,\r\n                formatTotal: PropTypes.func,\r\n                totals: PropTypes.string,\r\n\r\n                // column props, affecting colgroup > col tags\r\n                background: PropTypes.string,\r\n                border: PropTypes.string,\r\n                width: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),\r\n                \r\n                // works pretty shitty in col tag\r\n                minWidth: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),\r\n                CellComponent: PropTypes.elementType,\r\n                getCellExtraProps: PropTypes.func\r\n            })\r\n        ])\r\n    ).isRequired,\r\n\r\n    getRowData: PropTypes.func.isRequired,\r\n    getRowProps: PropTypes.func,\r\n    renderTfootContent: PropTypes.func,\r\n    renderHeaderCells: PropTypes.func,\r\n    Row: PropTypes.elementType,\r\n    Cell: PropTypes.elementType,\r\n\r\n    headless: PropTypes.bool,\r\n};\r\n\r\n/*\r\n    Spread operator will kill pure annotation comment, and tree-shaking will fail.\r\n    So Object.assign is a must\r\n*/\r\nTable.defaultProps = /*#__PURE__*/ Object.assign({}, commonDefaultProps, {\r\n    headless: false,\r\n\r\n    renderRow,\r\n    Row,\r\n    renderHeaderCells,\r\n    Cell\r\n});\r\n\r\nexport default memo( Table );","/*\n    If all cells in a row would be completely empty - row can \"collapse\" short.\n    To prevent it we can fill it with &nbsp;\n*/\nconst DEFAULT_EMPTY_CELL_CONTENT = \"\\u00A0\";\n\nexport const Row = ({ index, columns, getRowData, getRowProps, Cell }) => {\n\n    const rowData = getRowData( index );\n\n    return (\n        <tr {...(rowData&&getRowProps&&getRowProps(rowData,index))}>\n            {rowData ? columns.map( column => (\n                <td key={column.dataKey}>\n                    <Cell rowData={rowData} column={column} />\n                </td>\n            )) : (\n                <td colSpan={columns.length}>\n                    {DEFAULT_EMPTY_CELL_CONTENT}\n                </td>\n            )}\n        </tr>\n    );\n}\n\nexport const renderRow = RowProps => <RowProps.Row key={RowProps.index} {...RowProps} />\n\nexport const renderHeaderCells = columns => columns.map( column => (\n    <th key={column.dataKey} style={{ minWidth: column.minWidth }}>\n        {column.label}\n    </th>\n));\n\nexport const Cell = ({ rowData, column }) => {\n    const { render, dataKey, format } = column;\n\n    let cellData = rowData[ dataKey ];\n    \n    if( cellData === undefined ){\n        return DEFAULT_EMPTY_CELL_CONTENT;\n    }\n\n    if( render ){\n        return render( cellData, rowData );\n    }\n\n    if( format ){\n        return format( cellData );\n    }\n\n    return cellData;\n}"],"sourceRoot":""}