{"version":3,"sources":["webpack://af-virtual-scroll/./src/Context.js","webpack://af-virtual-scroll/./src/components/common/HeightProvider/style.module.scss?9ac1","webpack://af-virtual-scroll/./src/components/common/HeightProvider/index.js","webpack://af-virtual-scroll/./src/components/common/ScrollContainer/style.module.scss?e713","webpack://af-virtual-scroll/./src/components/common/ScrollContainer/index.js","webpack://af-virtual-scroll/./src/constants/events.js","webpack://af-virtual-scroll/./src/hooks/useApi/index.js","webpack://af-virtual-scroll/./src/hooks/useModel/index.js","webpack://af-virtual-scroll/./src/hooks/useForceUpdate/index.js","webpack://af-virtual-scroll/./src/hooks/useSubscription/index.js","webpack://af-virtual-scroll/./src/models/FixedSizeList/index.js","webpack://af-virtual-scroll/./src/utils/throttle/index.js","webpack://af-virtual-scroll/./src/models/ListBase/index.js","webpack://af-virtual-scroll/./src/models/PubSub/index.js","webpack://af-virtual-scroll/./src/models/VariableSizeList/index.js","webpack://af-virtual-scroll/./src/utils/cx/index.js","webpack://af-virtual-scroll/./src/utils/heightObserver/index.js"],"names":["createContext","E","WIDGET_SCROLL_HEIGHT","WIDGET_EXTRA_STICKY_HEIGHT","useSubscription","API","className","css","style","height","widgetScrollHeight","extraStickyHeight","children","props","ref","useRef","useApi","useEffect","el","current","setScrollContainerNode","observe","setWidgetHeight","unobserve","tabIndex","cx","onScroll","e","setScrollTop","target","scrollTop","START_INDEX","END_INDEX","ROWS_QUANTITY","EVENTS_ARRAY_LENGTH","useContext","Context","StoreConstructor","dataRef","estimatedRowHeight","overscanRowsCount","rowsQuantity","rowsContainerNode","finalDataRef","Store","startBatch","setViewParams","endBatch","destructor","increment","x","useReducer","callBack","events","prevRenderRef","forceUpdate","useForceUpdate","on","off","inBatch","queue","FixedSizeList","rowHeight","measureRowsThrottled","setRowHeight","v","this","remeasure","getIndex","offset","Math","trunc","getOffset","index","measureRows","firstElementChild","offsetHeight","ListBase","fn","ms","ctx","timer","invoke","call","throttled","setTimeout","cancel","clearTimeout","widgetHeight","scrollContainerNode","throttle","startIndex","endIndex","virtualTopOffset","updateWidgetScrollHeight","updateEndIndex","node","updateVisibleRange","updateExtraStickyHeight","delta","emit","min","max","scrollToRow","rowIndex","_E","Array","from","length","_Q","Set","_on","shouldPrepend","prototype","unshift","push","evt","prependListener","splice","clear","indexOf","cb","add","VariableSizeList","rowHeights","fTree","msb","grow","Error","clz32","curRowHeighsLength","oldRowHeights","Uint32Array","set","fill","j","i","tempIndex","bitMask","result","updateRowHeight","limitTreeLiftingIndex","diff","buff","lim","baseClass","extraClass","callBacks","Map","R","ResizeObserver","entries","entry","get","round","contentRect","delete"],"mappings":"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","file":"b61663422e512bdee432.js","sourcesContent":["import { createContext } from \"react\";\r\n\r\nexport default createContext();","// extracted by mini-css-extract-plugin\nexport default {\"wrapper\":\"a2uMg3Zj4kpPT6J8EoqLx\"};","import useSubscription from \"hooks/useSubscription\";\nimport css from \"./style.module.scss\";\nimport { WIDGET_SCROLL_HEIGHT, WIDGET_EXTRA_STICKY_HEIGHT } from \"constants/events\";\n\nconst E = [ WIDGET_SCROLL_HEIGHT, WIDGET_EXTRA_STICKY_HEIGHT ];\n\nconst HeightProvider = () => useSubscription( API => (\n    <div\n        className={css.wrapper}\n        style={{ height: API.widgetScrollHeight + API.extraStickyHeight }}\n    />\n), E );\n\nexport default HeightProvider","// extracted by mini-css-extract-plugin\nexport default {\"wrapper\":\"_3Jl24WrVf4wfsfDMBe4LVm\"};","import { useRef, useEffect } from \"react\";\r\nimport cx from \"utils/cx\";\r\nimport { observe, unobserve } from \"utils/heightObserver\";\r\nimport useApi from \"hooks/useApi\";\r\nimport HeightProvider from \"../HeightProvider\";\r\nimport css from \"./style.module.scss\";\r\n\r\nconst ScrollContainer = ({ className, children, ...props }) => {\r\n\r\n    const ref = useRef();\r\n    const API = useApi();\r\n\r\n    useEffect(() => {\r\n        const el = ref.current;\r\n\r\n        API.setScrollContainerNode( el );\r\n\r\n        observe( el, height => API.setWidgetHeight( height ) );\r\n\r\n        return () => unobserve( el );\r\n    }, []);\r\n    \r\n    /*\r\n        tabIndex=\"0\" is for proper keyboard nav\r\n        https://bugzilla.mozilla.org/show_bug.cgi?id=1346159\r\n    */\r\n    return (\r\n        <div\r\n            {...props}\r\n            tabIndex=\"0\"\r\n            className={cx(css.wrapper,className)}\r\n            ref={ref}\r\n            onScroll={e => API.setScrollTop( e.target.scrollTop )}\r\n        >\r\n            <HeightProvider />\r\n            {children}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default ScrollContainer;","export const START_INDEX                    = 0;\nexport const END_INDEX                      = 1;\nexport const ROWS_QUANTITY                  = 2;\nexport const WIDGET_SCROLL_HEIGHT           = 3;\nexport const WIDGET_EXTRA_STICKY_HEIGHT     = 4;\n\nexport const EVENTS_ARRAY_LENGTH            = 5;","import { useContext } from \"react\";\nimport Context from \"../../Context\";\n\nconst useApi = () => useContext( Context );\n\nexport default useApi;","import { useRef, useEffect } from \"react\";\n\n/*\n    dataRef is to call Data methods from outside( Data.scrollTo(), etc. ).\n    As it is not dom-related, I decided to avoid forwardRef\n*/\nconst useStore = ( StoreConstructor, dataRef, estimatedRowHeight, overscanRowsCount, rowsQuantity, rowsContainerNode ) => {\n\n    const finalDataRef = useRef();\n\n    let Store = finalDataRef.current;\n\n    if( !( Store instanceof StoreConstructor ) ){\n        Store = finalDataRef.current = new StoreConstructor();\n    }\n\n    if( dataRef ){\n        dataRef.current = Store;\n    }\n\n    Store.startBatch().setViewParams( estimatedRowHeight, overscanRowsCount, rowsQuantity, rowsContainerNode );\n\n    useEffect(() => {\n        Store.endBatch();\n    });\n    \n    useEffect(() => () => Store.destructor(), [ Store ]);\n\n    return Store;\n};\n\nexport default useStore;","import { useReducer } from \"react\";\n\nconst increment = x => x + 1;\n\nconst useForceUpdate = () => useReducer( increment, 0 )[ 1 ];\n\nexport default useForceUpdate;","import { useRef, useEffect } from \"react\";\nimport useForceUpdate from \"../useForceUpdate\";\nimport useApi from \"../useApi\";\n\nconst useSubscription = ( callBack, events ) => {\n    \n    const prevRenderRef = useRef( null );\n    const API = useApi();\n    const forceUpdate = useForceUpdate();\n    \n    useEffect(() => {\n        API.on( forceUpdate, ...events );\n        return () => API.off( forceUpdate, ...events );\n    }, events );\n\n    if( API.inBatch ){\n        /*\n            Somebody tried to rerender, while we were in batch.\n            On batch finish component definitely must be rerendered.\n        */\n        API.queue( forceUpdate );\n    }\n    else{\n        prevRenderRef.current = callBack( API );\n    }\n    \n    return prevRenderRef.current;\n}\n\nexport default useSubscription;","import ListBase from \"../ListBase\";\n\nimport { ROWS_QUANTITY } from \"constants/events\";\n\nclass FixedSizeList extends ListBase {\n\n    rowHeight = 0;\n\n    setRowHeight( v ){\n        if( v !== this.rowHeight ){\n            this.rowHeight = v;\n            this.remeasure();\n        }\n    }\n\n    constructor(){\n        super();\n\n        this.on( this.measureRowsThrottled, ROWS_QUANTITY );\n    }\n\n\n    getIndex( offset ){\n        /* rounding via bitwise hacks like |0 may not work here, because number may be > max(int32) */\n        return this.rowHeight && Math.trunc( offset / this.rowHeight );\n    }\n\n    getOffset( index ){\n        return index * this.rowHeight;\n    }\n\n    measureRows(){\n        if( this.rowsContainerNode && this.rowsQuantity ){\n            this.setRowHeight( this.rowsContainerNode.firstElementChild?.offsetHeight || 0 );\n        }\n    }    \n}\n\nexport default FixedSizeList;","const throttle = ( fn, ms, ctx ) => {\n    let timer = 0;\n\n    const cancel = () => {\n        clearTimeout( timer );\n        timer = 0;\n    }\n\n    const invoke = () => {\n        timer = 0;\n        fn.call( ctx );\n    }\n\n    const throttled = () => {\n        if( timer === 0 ){\n            timer = setTimeout( invoke, ms );\n        }\n    }\n\n    throttled.cancel = cancel;\n\n    return throttled;\n}\n\nexport default throttle;","import PubSub from \"../PubSub\";\nimport throttle from \"utils/throttle\";\n\nimport {\n    START_INDEX,\n    END_INDEX,\n    ROWS_QUANTITY,\n    WIDGET_SCROLL_HEIGHT,\n    WIDGET_EXTRA_STICKY_HEIGHT\n} from \"constants/events\";\n\nclass ListBase extends PubSub {\n\n    /* Provided from renderer */\n    scrollTop = 0;\n\n    rowsQuantity = 0;\n\n    /* must not be >= 1 */\n    overscanRowsCount = 2;\n\n    widgetHeight = 0;\n\n    /* sticky elements ( for example table header/footer ) must influence ONLY on widgetScrollHeight */\n    extraStickyHeight = 0;\n\n    estimatedRowHeight = 0;\n\n    rowsContainerNode = null;\n    scrollContainerNode = null;\n\n    setScrollContainerNode( node ){\n        this.scrollContainerNode = node;\n    }\n\n    setScrollTop( v ){\n        if( v !== this.scrollTop ){\n            this.scrollTop = v;\n            this.updateVisibleRange();\n        }\n    }\n\n    setWidgetHeight( height ){\n        if( height !== this.widgetHeight ){\n            this.widgetHeight = height;\n            this.updateEndIndex();\n        }\n\n        this.measureRowsThrottled();\n    }\n\n    updateExtraStickyHeight( delta ){\n        if( delta ){\n            this.extraStickyHeight += delta;\n            this.emit( WIDGET_EXTRA_STICKY_HEIGHT );\n        }\n    }\n\n    updateEndIndex(){\n\n        const endIndex = Math.min( this.getIndex( this.scrollTop + this.widgetHeight ) + this.overscanRowsCount, this.rowsQuantity );\n\n        if( endIndex !== this.endIndex ){\n            this.endIndex = endIndex;\n            this.emit( END_INDEX );\n        }\n\n        return this;\n    }\n\n    updateVisibleRange(){\n\n        const startIndex = Math.max( 0, this.getIndex( this.scrollTop ) - this.overscanRowsCount );\n\n        if( startIndex !== this.startIndex ){\n            this.startIndex = startIndex;\n            this.virtualTopOffset = this.getOffset( startIndex );\n            this.emit( START_INDEX );\n        }\n\n        return this.updateEndIndex();\n    }\n\n\n    /* must be called when row height/heights change */\n    remeasure(){\n        return this\n            .updateWidgetScrollHeight()\n            .updateVisibleRange();\n    }\n\n    constructor(){\n        super()\n\n        this\n            .on( this.updateWidgetScrollHeight, ROWS_QUANTITY )\n            .on( this.updateEndIndex, ROWS_QUANTITY );\n    }\n\n    destructor(){\n        this.measureRowsThrottled.cancel();\n        super.destructor();\n    }\n\n    scrollToRow( rowIndex ){\n        if( this.scrollContainerNode ){\n            this.scrollContainerNode.scrollTop = this.getOffset( rowIndex );\n        }\n        else if( process.env.NODE_ENV !== \"production\" ){\n            console.error( \"scrollContainerNode is not set\" );\n        }\n    }\n\n    updateWidgetScrollHeight(){\n        const v = this.getOffset( this.rowsQuantity );\n        if( v !== this.widgetScrollHeight ){\n            this.widgetScrollHeight = v;\n            this.emit( WIDGET_SCROLL_HEIGHT );\n        }\n        return this;\n    }\n\n    \n\n    setViewParams( estimatedRowHeight, overscanRowsCount, rowsQuantity, rowsContainerNode ){\n\n        this.estimatedRowHeight = estimatedRowHeight;\n        this.rowsContainerNode = rowsContainerNode;\n\n        this.startBatch();\n\n        if( overscanRowsCount !== this.overscanRowsCount ){\n            this.overscanRowsCount = overscanRowsCount;\n            this.queue( this.updateVisibleRange );\n        }\n\n        if( rowsQuantity !== this.rowsQuantity ){\n            this.rowsQuantity = rowsQuantity;\n            this.emit( ROWS_QUANTITY );\n        }\n\n        this.endBatch();\n    }\n\n    measureRowsThrottled = throttle( this.measureRows, 200, this );\n\n    /* Calculated inside model */\n    startIndex = 0;\n    endIndex = 0;\n    virtualTopOffset = 0;\n    widgetScrollHeight = 0;\n}\n\nexport default ListBase;","import { EVENTS_ARRAY_LENGTH } from \"constants/events\";\n\nclass PubSub {\n\n    /* All callbacks are known in advance, so we can allocate in construcror */\n    _E = Array.from({ length: EVENTS_ARRAY_LENGTH }, () => []);\n\n    /* query of callbacks, that should run after batch end */\n    _Q = new Set();\n\n    /* depth of batch */\n    inBatch = 0;\n\n    _on( callBack, events, shouldPrepend ){\n        const fn = shouldPrepend ? Array.prototype.unshift : Array.prototype.push;\n        for( let evt of events ){\n            fn.call( this._E[ evt ], callBack );\n        }\n        return this;\n    }\n\n    on( callBack, ...events ){\n        return this._on( callBack, events, false );\n    }\n\n    prependListener( callBack, ...events ){\n        return this._on( callBack, events, true );\n    }\n\n    destructor(){\n        for( let events of this._E ){\n            events.splice( 0 );\n        }\n        this._Q.clear();\n    }\n\n    off( callBack, ...events ){\n        for( let evt of events ){\n            this._E[ evt ].splice( this._E[ evt ].indexOf( callBack ) >>> 0, 1 );\n        }\n        return this;\n    }\n\n    queue( cb ){\n        if( process.env.NODE_ENV !== \"production\" ){\n            if( !this.inBatch ){\n                console.error( \"trying to add event to batch queue, while inBatch is 0\" );\n            }\n        }\n        this._Q.add( cb );\n    }\n\n    emit( evt ){\n        if( this.inBatch ){\n            for( let cb of this._E[ evt ] ){\n                this._Q.add( cb );\n            }\n        }\n        else{\n            for( let cb of this._E[ evt ] ){\n                cb.call( this );\n            }\n        }\n        return this;\n    }\n\n    /* inspired by mobx */\n\n    startBatch(){\n        this.inBatch++;\n        return this;\n    }\n\n    endBatch(){\n        if( !--this.inBatch ){\n            for( let cb of this._Q ){\n                cb.call( this );\n            }\n            this._Q.clear();\n        }\n        return this;\n    }\n}\n\nexport default PubSub;","import ListBase from \"../ListBase\";\n\nimport {\n    ROWS_QUANTITY,\n    START_INDEX,\n    END_INDEX,\n} from \"constants/events\";\n\nclass VariableSizeList extends ListBase {\n    \n    rowHeights = [];\n    fTree = [];\n\n    /*\n        most significant bit of this.rowsQuantity;\n        caching it to avoid Math.clz32 calculations on every getIndex call\n    */\n    msb = 0;\n    \n    constructor(){\n        super();\n\n        this\n            /* must be done before events, attached in ListBase */\n            .prependListener( this.grow, ROWS_QUANTITY )\n            .on( this.measureRowsThrottled, START_INDEX, END_INDEX );            \n    }\n\n    grow(){\n        const { rowsQuantity } = this;\n\n        if( rowsQuantity < 0 || rowsQuantity > 0x7fffffff ){\n            throw new Error( `Wrong rowsQuantity: ${rowsQuantity}. Must be 0...2_147_483_647.` )\n        }\n\n        this.msb = rowsQuantity && 1 << 31 - Math.clz32( rowsQuantity );\n\n        const curRowHeighsLength = this.rowHeights.length;\n\n        if( rowsQuantity > curRowHeighsLength ){\n\n            const oldRowHeights = this.rowHeights;\n            \n            this.rowHeights = new Uint32Array( rowsQuantity );\n            this.fTree = new Uint32Array( rowsQuantity + 1 );\n\n            this.rowHeights.set( oldRowHeights );\n            this.rowHeights.fill( this.estimatedRowHeight, curRowHeighsLength );\n\n\n            /* \n                Creating fenwick tree from an array in linear time;\n                It is much more efficient, than calling updateRowHeight N times.\n            */\n\n            this.fTree.set( this.rowHeights, 1 );\n\n            for( let i = 1, j; i <= rowsQuantity; i++ ){\n                j = i + ( i & -i );\n                if( j <= rowsQuantity ){\n                    this.fTree[ j ] += this.fTree[ i ];\n                }\n            }\n\n            this.remeasure();\n        }        \n    }\n\n    getIndex( offset ){\n        let index = 0;\n        \n        for( let bitMask = this.msb, tempIndex; bitMask !== 0; bitMask >>= 1 ){\n            tempIndex = index + bitMask;\n            if( tempIndex > this.rowsQuantity ){\n                continue;\n            }\n            if( offset === this.fTree[ tempIndex ] ){\n                return tempIndex;\n            }\n            if( offset > this.fTree[ tempIndex ] ) {\n                offset -= this.fTree[ tempIndex ];\n                index = tempIndex;\n            }\n        }\n\n        return index;\n    }\n\n    getOffset( index ){\n        if( process.env.NODE_ENV !== \"production\" ){\n            if( index > this.rowsQuantity ){\n                throw new Error( \"index must not be > rowsQuantity\" );\n            }\n        }\n\n        let result = 0;\n\n        for ( ; index > 0; index -= index & -index ){\n            result += this.fTree[ index ];\n        }\n\n        return result;\n    }\n\n    /* i starts from 1 here; */\n    updateRowHeight( i, delta, limitTreeLiftingIndex ){\n        for ( ; i < limitTreeLiftingIndex; i += i & -i ){\n            this.fTree[ i ] += delta;\n        }\n    }\n\n    measureRows(){\n        const node = this.rowsContainerNode;\n\n        if( node ){\n\n            let index = this.startIndex,\n                diff,\n                buff = 0;\n            \n            /* We can batch-update fenwick tree, if we know, that all indexes are updated in +1 - order. */\n            const lim = Math.min( this.fTree.length, 1 << 32 - Math.clz32( this.endIndex - 1 ) );\n\n            for( let child of node.children ){\n     \n                diff = child.offsetHeight - this.rowHeights[ index ];\n\n                if( diff ){\n                    this.rowHeights[ index ] += diff;\n                    buff += diff;\n                    this.updateRowHeight( index + 1, diff, lim );                  \n                }\n                \n                index++;\n            }\n\n            if( buff ){\n                this.updateRowHeight( lim, buff, this.fTree.length );\n                this.remeasure();\n            }\n        }\n    }\n}\n\nexport default VariableSizeList;","const cx = ( baseClass, extraClass ) => extraClass ? `${baseClass} ${extraClass}` : baseClass;\r\n\r\nexport default cx;","const callBacks = new Map();\n\nconst R = new ResizeObserver( entries => {\n    for( let entry of entries ){\n        const cb = callBacks.get( entry.target );\n        if( cb ){\n            cb( Math.round( entry.contentRect.height ) )\n        }\n    }\n});\n\nexport const observe = ( el, callBack ) => {\n    callBacks.set( el, callBack );\n    R.observe( el );\n}\n\nexport const unobserve = el => callBacks.delete( el ) && R.unobserve( el );"],"sourceRoot":""}